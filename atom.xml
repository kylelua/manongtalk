<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>码农说</title>
  <subtitle>一个程序员的日常</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://manongtalk.com/"/>
  <updated>2016-11-13T21:08:10.427Z</updated>
  <id>http://manongtalk.com/</id>
  
  <author>
    <name>卤蛋侠</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何用Python实现一个简单的人工神经网络(Artificial Neural Network)</title>
    <link href="http://manongtalk.com/2016/11/13/2016-10-13-ann/"/>
    <id>http://manongtalk.com/2016/11/13/2016-10-13-ann/</id>
    <published>2016-11-13T21:05:36.000Z</published>
    <updated>2016-11-13T21:08:10.427Z</updated>
    
    <content type="html"><![CDATA[<p>人工神经网络(Artificial Neural Network，ANN)的最初灵感来自于大脑神经系统的工作方式。人们的大脑通过从例子中总结经验来学习新的东西。经过训练的ANN同样可以用于图像识别和数据分类。生物学告诉我们，大脑里有大量的神经元，构成了复杂的网络。每个神经元之间通过突触传递介质（如：乙酰胆碱，多巴胺等）从而传递信息。我们可以把模型简化为：每个神经元可以许多其它神经细胞对其进行输入，然后它把这些输入加权，如果加权后的值高于一定阈值，则会激发该细胞产生一个输出。<br><a id="more"></a><br><img src="" alt=""></p>
<p>在计算机科学中， 我们完全可以模仿这个生物过程，造出一个人造神经网络。这个神经网络其实可以理解为生物神经系统的抽象。为了做简单说明，这篇文章把只考虑一个非常简化的模型：网络只有两层；并且试图解决一个线性的归类问题。</p>
<p>假设我们有一组训练集合，如下面的表格：</p>
<p><img src="" alt=""></p>
<p>我们希望下次输入后，计算机能预言出合理的输出结果。（仔细看表格我们可以总结出规律，输出只和输入3相关，所以结果应该是1）</p>
<p><img src="" alt=""></p>
<p>训练的过程如下：</p>
<ol>
<li><p>向前推进：<br>把输入的参数加权求和（权重为随机数）：<br>Y = Weight1 <em> Input1 + Weight2 </em> Input2 + Wight3 * Input3<br>把求和的结果通过sigmoid函数归一化，从而获得一个0和1之间的结果。<br>注：sigmoid 函数公式为  y = 1 / (1 + exp(-x))</p>
</li>
<li><p>向后检验：<br>计算误差。在我们的例子中，我把误差定义为真实的输出于预测输出的差。之后我们根据误差重新调整权重。设 权重Weight, 误差Error, 输入Input, 输出Output, 则公式如下：<br>Weight = Weight + Error <em> Input </em> Output * ( 1 - Output )</p>
</li>
</ol>
<p>反复重复以上步骤。</p>
<p>以下是python代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">from numpy import *</div><div class="line"> </div><div class="line">class NeuralNet(object):</div><div class="line">    def __init__(self):</div><div class="line">        # Generate random numbers</div><div class="line">        random.seed(1)</div><div class="line"> </div><div class="line">        # Assign random weights to a 3 x 1 matrix,</div><div class="line">        self.synaptic_weights = 2 * random.random((3, 1)) - 1</div><div class="line"> </div><div class="line">    # The Sigmoid function</div><div class="line">    def __sigmoid(self, x):</div><div class="line">        return 1 / (1 + exp(-x))</div><div class="line"> </div><div class="line">    # The derivative of the Sigmoid function.</div><div class="line">    # This is the gradient of the Sigmoid curve.</div><div class="line">    def __sigmoid_derivative(self, x):</div><div class="line">        return x * (1 - x)</div><div class="line"> </div><div class="line">    # Train the neural network and adjust the weights each time.</div><div class="line">    def train(self, inputs, outputs, training_iterations):</div><div class="line">        for iteration in xrange(training_iterations):</div><div class="line"> </div><div class="line">            # Pass the training set through the network.</div><div class="line">            output = self.learn(inputs)</div><div class="line"> </div><div class="line">            # Calculate the error</div><div class="line">            error = outputs - output</div><div class="line"> </div><div class="line">            # Adjust the weights by a factor</div><div class="line">            factor = dot(inputs.T, error * self.__sigmoid_derivative(output))</div><div class="line">            self.synaptic_weights += factor</div><div class="line"> </div><div class="line">    # The neural network thinks.</div><div class="line">    def learn(self, inputs):</div><div class="line">        return self.__sigmoid(dot(inputs, self.synaptic_weights))</div><div class="line"> </div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line"> </div><div class="line">    #Initialize</div><div class="line">    neural_network = NeuralNet()</div><div class="line"> </div><div class="line">    # The training set.</div><div class="line">    inputs = array([[0, 1, 1], [1, 0, 0], [1, 0, 1]])</div><div class="line">    outputs = array([[1, 0, 1]]).T</div><div class="line"> </div><div class="line">    # Train the neural network</div><div class="line">    neural_network.train(inputs, outputs, 10000)</div><div class="line"> </div><div class="line">    # Test the neural network with a test example.</div><div class="line">    print neural_network.learn(array([1, 0, 1]))</div></pre></td></tr></table></figure>
<p>输出结果：当迭代10次以后，神经网络的预测结果是0.6598. 和正确答案1相比，这个结果并不够好。我们尝试着增加迭代次数，可以看到当迭代超过100次时预测结果达到0.8768，而迭代超过10000次后结果是0.9898，已经接近实际值。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人工神经网络(Artificial Neural Network，ANN)的最初灵感来自于大脑神经系统的工作方式。人们的大脑通过从例子中总结经验来学习新的东西。经过训练的ANN同样可以用于图像识别和数据分类。生物学告诉我们，大脑里有大量的神经元，构成了复杂的网络。每个神经元之间通过突触传递介质（如：乙酰胆碱，多巴胺等）从而传递信息。我们可以把模型简化为：每个神经元可以许多其它神经细胞对其进行输入，然后它把这些输入加权，如果加权后的值高于一定阈值，则会激发该细胞产生一个输出。&lt;br&gt;
    
    </summary>
    
    
      <category term="AI" scheme="http://manongtalk.com/tags/AI/"/>
    
      <category term="Machine Learning" scheme="http://manongtalk.com/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>所谓架构，即非架构，是名架构</title>
    <link href="http://manongtalk.com/2016/11/12/2016-11-12-archi-03/"/>
    <id>http://manongtalk.com/2016/11/12/2016-11-12-archi-03/</id>
    <published>2016-11-12T05:21:57.000Z</published>
    <updated>2016-11-13T05:29:15.351Z</updated>
    
    <content type="html"><![CDATA[<p>世上本没有架构，关注点一分离，就有了架构。<a id="more"></a></p>
<p>人们不断将各种关注点分离，形成了不同的架构风格。然而是否分离、何时分离、怎样分离，却是“运用之妙，存乎一心”。</p>
<p>Facebook实现了社会关系数据和隐私设定的关注点分离，运用的手段是云计算，提出了新的Web应用架构，PaaS Facebook Web Service API和FBQL是对数据持久的关注点分离，FBML和JS库是对数据展现的关注点分离。还是三层架构，没有新东西。人们总是和过去的自己只有一点点不同。</p>
<p>凡所有相，皆是虚妄，若见诸相非相，即见如来。</p>
<p>凡夫者，如来说即非凡夫，是名凡夫。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;世上本没有架构，关注点一分离，就有了架构。
    
    </summary>
    
    
      <category term="架构" scheme="http://manongtalk.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="杂谈" scheme="http://manongtalk.com/tags/%E6%9D%82%E8%B0%88/"/>
    
      <category term="随想" scheme="http://manongtalk.com/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>App架构思考：如何设计</title>
    <link href="http://manongtalk.com/2016/11/10/2016-11-10-archi-02/"/>
    <id>http://manongtalk.com/2016/11/10/2016-11-10-archi-02/</id>
    <published>2016-11-11T04:54:04.000Z</published>
    <updated>2016-11-13T05:02:25.206Z</updated>
    
    <content type="html"><![CDATA[<p>当我们完成了架构规划以后，整理出一堆不同优先级的需求，尤其是质量需求之后，接下来就要思考如何才能最大限度地实现这些需求，这就是架构设计要解决的问题。那么，如何进行架构设计呢？设计到什么程度才合适呢？我们现在从<strong>架构思维</strong>和<strong>架构原则</strong>方面来聊聊。</p>
<a id="more"></a>
<p><strong>架构思维</strong></p>
<p>这里说的架构思维是指进行架构设计时最高层级的思考方式，比如：面向过程、面向对象、面向切面、面向服务等。</p>
<p><strong>面向过程(Procedure Oriented)</strong></p>
<p>面向过程的设计思路就是将问题分解成一个个步骤，按照步骤一步步执行之后，问题就解决了。每一个步骤就是一个子过程，也可以称为一个模块，子过程还可以继续拆分成更多更细的子过程。因此，面向过程的设计核心就是过程分析、功能分解，一般采用自顶向下、逐步求精的分解方式。一个大的程序可以分解成多个子程序，子程序再分解成多个大模块，大模块再分解成多个小模块，最终分解成一个个函数。</p>
<p>在此我想借用一个象棋对战的例子。以下是采用面向过程的设计思路分解的对战流程图：</p>
<p><img src="https://raw.githubusercontent.com/kylelua/manongtalk/master/img/2016-11-10-archi/13-46-54.jpg" alt=""></p>
<p>将以上每个流程分别用函数实现，问题就解决了。</p>
<p>面向过程的优点主要有两个：一是流程清晰简单；二是性能比较高。尤其是性能，这也是为什么至今很多单片机开发、驱动程序开发、或其他与硬件相关的系统开发等对性能要求很高的软硬件程序依然在用面向过程的方式进行设计和开发。</p>
<p>面向过程的缺点也很明显：一是主程序太重，主程序与模块承担的任务不均衡；二是函数不易扩展，导致其可扩展性、可复用性、可维护性相对都比较差；三是上下层级模块之间的联系太紧密，耦合高，所以模块也难以复用。</p>
<p><strong>面向对象(Object Oriented)</strong></p>
<p>面向过程的思路是“怎么做”，关注于实现细节；而面向对象的思路是“谁来做”，关注于抽象的对象。对象的封装、继承和多态等特性，让我们以更接近现实世界的方式来思考程序设计。面向对象相比面向过程容易实现更好的分离，相应地可扩展性、可复用性、可维护性也会比较高，但同时会牺牲掉一些性能。不过，也因为硬件发展迅猛，所以牺牲的那点性能也不算什么了。</p>
<p>面向对象设计的难点在于抽象，从问题域中抽象出一个个对象，并找出它们之间的关系。好在有SOLID原则和一大堆设计模式指导我们如何更好地设计。也有领域驱动设计的方法论指导我们怎么进行领域建模。</p>
<p>还是象棋对战的例子，用面向对象的设计思路，可以抽象出以下三种对象：</p>
<p>棋手：负责行棋，红黑两方行为一致。<br>棋盘：负责绘制棋盘画面。<br>裁判：负责判定吃子、犯规和输赢等。<br>三者关系如下图：</p>
<p><img src="https://raw.githubusercontent.com/kylelua/manongtalk/master/img/2016-11-10-archi/13-56-53.jpg" alt=""></p>
<p>棋手对象行棋后，棋盘对象根据棋子布局的变化刷新棋盘画面，裁判对象则对棋局进行判定。</p>
<p><strong>面向切面(Aspect Oriented)</strong></p>
<p>面向切面，也就是AOP，是对面向对象的一种扩展，为了弥补面向对象的局限性。面向对象设计主要是对业务领域进行抽象封装，但对于业务领域之外的内容，比如日志记录、权限检查、事务支持等，在没有AOP之前，只能将实现这些功能的代码散布在所有对象层次中，但这些代码与所散布的对象的核心业务功能是没任何关系的。这种做法也导致了大量重复的代码，而且难以复用。AOP就是为了解决这种问题而产生的，将这些与业务领域无关的部分分离出来，以横切面的方式注入系统，从而减少重复代码、减低耦合度、增强扩展性和维护性。</p>
<p>将日志记录、权限检查、事务支持等等使用横切技术分别独立成一个个服务模块，这些模块也称为“横切面”，这样就可以将这些与业务无关的服务从业务核心中解耦出来，就可以将系统划分为两部分：业务核心和通用服务。业务核心依然采用面向对象的思路去设计，而通用服务则可以采用面向切面的思想来实现。</p>
<p>Spring就大量使用了AOP技术，OkHttp的Interceptor也是AOP设计的一种实现。很多场景都可以使用AOP的思想去设计，比如添加统一的Http Request Header，添加统一的登录验证，添加统一的缓存，添加统一的错误处理，等等，只要是通用的功能点基本都可以使用AOP的思想去设计和实现。</p>
<p><strong>面向服务(Service Oriented)</strong></p>
<p>不管是SOA还是现在流行的微服务架构，都是采用面向服务的思维方式。说到面向服务，需要先了解一个概念：Monolith，也称为单体架构。在没有SOA思想之前，软件系统将所有功能整合成一个独立的软件包，然后部署在单一的平台上。比如，在J2EE平台，一个软件系统最终会打成一个包含所有功能的WAR包，然后部署到Web容器中。若要扩展的话，则通过复制这个WAR包部署到多个Web容器来实现。这种方式，如果程序需要改动，不管多么微小的改动，都需要重新打包个新的WAR包，并替换掉所有Web容器的旧WAR包。</p>
<p>面向服务的架构思想则是，将系统的不同功能分离成一个个单独的应用程序或组件，统称为服务，不同服务部署在不同容器中，不同服务之间通过一些轻量级的交互机制来通信，如HTTP，RPC等。这样，相比单体架构，功能服务之间明显是松耦合的，扩展也会灵活很多。而且，不同服务还可以用不同编程语言实现，部署到不同平台。</p>
<p>不管是面向过程，面向对象，面向切面，还是面向服务，最本质的区别还是在于看问题的角度不同。而在实际应用中，也不会只使用一种架构思维，而是综合考虑的，系统的不同方面或不同层级可能会用不同的架构思维去思考。比如，一个庞大的复杂系统，整体上可能用面向服务的架构思维去拆解各种服务，业务核心方面的服务可能再用面向对象的架构思维进行建模，通用功能服务还是用面向切面的架构思维来设计，事务流程当然是采用面向过程的架构思维最直观。</p>
<p><strong>架构原则</strong></p>
<p>架构思维从面向过程，到现在的面向服务，以后也不知道还会出现什么新的思维方式。但无论是何种思维方式，都存在一些共通性的架构原则，可以指导我们如何设计出一个合适的架构。从另一方面来说，架构设计，不管是面向过程、面向对象、面向切面，还是面向服务，无一例外，主要都是在对复杂的系统进行分解。那么，相应地，就需要思考三个问题：<strong>分解为哪些？如何分解？分解到什么程度？</strong>相对应地，有三个重要原则可以分别为解答这三个问题提供指引。</p>
<p><strong>关注点分离原则</strong></p>
<p>关注点分离原则主要就是为了解决将复杂系统分解为哪些部分的问题，分解出来的部分就是关注点。过程、对象、切面、服务，只是分解的角度（也是关注点）不同而已。将复杂的问题根据不同的关注点分解为多个相对简单的问题，再对每个简单的问题进行分别处理，这就是关注点分离。分离之后，各个关注点相对独立，每个关注点的变化基本不会影响到其他的关注点，即使需要改变，改变的部分也很小。需要扩展时，影响也将会最小化。</p>
<p>关注点分离，最难的在于如何识别出有哪些关注点。要识别出有哪些关注点，需要将复杂系统不同的方方面面抽象成一个个具有清晰明确的边界的概念模型，或为“对象”，或为“组件”，或“切面”，或“服务”，以将复杂问题分解为一个个相对简单的问题。</p>
<p>从不同维度，可以有不同的分离方案。除了上面提到的面向过程、面向对象、面向切面、面向服务等思维角度之外，还有如下图所示的其他几种不同维度：</p>
<p><img src="https://raw.githubusercontent.com/kylelua/manongtalk/master/img/2016-11-10-archi/23-09-11.jpg" alt=""></p>
<p>上图分别从功能职责、通用性、大小粒度的不同维度进行分离。从职责维度进行分离，就可以分为三层架构：展现层、业务层、数据层，相应的关注点就是：数据展示、数据加工、数据管理。另外，数据层还可以再分离为网络层和缓存层。从通用性维度来看，就可以分离出技术通用部分、领域通用部分、特定应用部分。一般，使用框架技术就可以用于分离各种不同的通用部分。从大小粒度的维度考虑，无非就是将复杂系统分离为各个子系统，再分离为不同模块，再细分到不同类。</p>
<p>在实际应用中，并不会只采用一种维度，而是多种维度综合考虑，不同部分采用不同维度的分离方案。比如，也许，整体上按职责分离为多层架构，然后，在某些层级根据大小粒度再进行分离，例如将业务层按照不同业务模块进行分离。另外，也会将不同的通用部分进行分离，例如可将技术通用部分的日志记录、领域通用部分的权限检查分别分离出来。</p>
<p><strong>高内聚低耦合原则</strong></p>
<p>系统应该如何分解？或者说关注点应该如何分离？高内聚低耦合原则就可以为该问题提供设计指引。</p>
<p>内聚是指模块内部的功能和元素之间的紧密程度，而耦合则是指模块与模块之间的关联程度。</p>
<p>内聚可分为好多种：功能内聚、顺序内聚、通信内聚、过程内聚、时间内聚、逻辑内聚、偶然内聚。功能内聚是最强最好的内聚，模块内各元素共同协作完成一个单一的功能，这些元素紧密联系、缺一不可。顺序内聚则是指，模块中各个处理元素和同一个功能密切相关，而且这些处理必须顺序执行，通常前一个处理元素的输出时后一个处理元素的输入。顺序内聚的内聚度也比较高，但相比功能内聚，缺点就是可维护性相对差些。偶然内聚则是最弱的内聚，模块内的各元素之间没有任何联系，只是偶然地被凑到一起。</p>
<p>耦合也分为好多种：非直接耦合、数据耦合、标记耦合、控制耦合、外部耦合、公共耦合、内容耦合。非直接耦合表示两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的，其耦合度是最弱的，模块独立性最强。数据耦合表示调用模块和被调用模块之间只传递简单的数据项参数，相当于高级语言中的值传递。标记耦合也称为特征耦合，表示调用模块和被调用模块之间传递的不是简单数据，而是数据结构，像高级语言中的数据名、记录名和文件名等数据结果，这些名字即为标记，其实传递的是地址。控制耦合则表示模块之间传递的不是数据信息，而是控制信息例如标志、开关等，一个模块控制了另一个模块的功能。外部耦合则是指一组模块都访问同一全局简单变量，而且不通过参数表传递该全局变量的信息。内容耦合则是一个模块直接访问另一模块的内容，这是最强的耦合。</p>
<p>高内聚的设计原则是说：一个模块只完成一个单一的功能，尽可能使模块达到功能内聚。<br>低耦合的设计原则是说：若模块间必须存在耦合，应尽量使用数据耦合，少用控制耦合，慎用或有控制地使用公共耦合，并限制公共耦合的范围，尽量避免内容耦合。</p>
<p><strong>适度设计</strong></p>
<p>适度设计原则关注的就是系统分解到什么程度的问题。适度设计就是指设计不要过度，也不要不足。那么，怎样才算设计过度？怎样才算设计不足？一句话，设计过度就是想太多，设计不足就是想太少。感觉好虚，是吧？我也这么觉得。因为，如何判断一个设计是否过度或不足，并没有标准的可量化指标。因此，设计是否适度，更多在于主观的判断。而如何避免设计过度或不足，更多的也在于个人经验积累所形成的直觉。</p>
<p>设计不足相对还比较容易判断，导致设计不足的原因主要有两个：一是因为新手的设计经验不足而导致；二是因为一味追求快速实现产品功能而跳过或大幅度减少了设计而导致。</p>
<p>也有些设计过度比较明显的例子，比如Uncle Bob提出的Clean架构，每个关注点都有着清晰明确的边界，架构真的很清晰，可维护性、可测试性都非常不错，高内聚低耦合。但是，如果将其应用到一个只有两三个开发人员的小团队的小项目中，就会明显发现代码量大而且复杂，每需要添加一个小功能，却需要编写大量代码。这对一个小团队小项目来说，明显不适合。Clean架构比较适用于人员较多的团队，和中大型项目。</p>
<p>因此，判断设计是否适度，不能脱离团队和项目的现状。另外，还有其他现状因素，包括各种商业需求、功能需求和质量需求。大部分情况下，形成过度设计的原因在于：一是过多地考虑了未来可能发生的变化；二是为了追求设计而设计。适度设计，首先应该着眼于当下，当下的需求、当下的开发成本、当下的人员和项目现状；其次才是适当考虑如何应对未来的变化。对于未来的变化，也不是任何可能都要考虑，只需考虑在可预见的未来里有非常大的几率会发生的变化即可，这个非常大的几率可以达到90%以上。比如，已经确定要实现的需求，只是因为优先级问题而稍微延后；比如，已经确定的人员扩充计划；比如，双11要搞活动，交易量将会激增；等等。</p>
<p>也就是说，适度设计的原则，可以总结为：设计应该优先满足当前确定的需求，再满足可预见未来里几乎可以确定会发生的需求。只满足当前需求而不考虑未来，就容易导致设计不足；而过多地考虑未来可能发生的需求，就容易导致设计过度。因此，适度设计需要在当前需求和未来需求之间做好平衡，而我觉得只考虑当前需求和未来几乎确定会发生的需求是最好的平衡点。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们完成了架构规划以后，整理出一堆不同优先级的需求，尤其是质量需求之后，接下来就要思考如何才能最大限度地实现这些需求，这就是架构设计要解决的问题。那么，如何进行架构设计呢？设计到什么程度才合适呢？我们现在从&lt;strong&gt;架构思维&lt;/strong&gt;和&lt;strong&gt;架构原则&lt;/strong&gt;方面来聊聊。&lt;/p&gt;
    
    </summary>
    
    
      <category term="架构" scheme="http://manongtalk.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>App架构思考：什么是架构？</title>
    <link href="http://manongtalk.com/2016/11/09/2016-11-10-archi-01/"/>
    <id>http://manongtalk.com/2016/11/09/2016-11-10-archi-01/</id>
    <published>2016-11-09T23:00:44.000Z</published>
    <updated>2016-11-12T23:09:30.782Z</updated>
    
    <content type="html"><![CDATA[<p>最近在思考架构方面一些最基本的问题，比如什么是架构？如何评价一个架构的好坏？是否有一些通用的基本原则指引架构设计？在面向对象设计方面，有单一职责、里氏替换、依赖倒置、接口隔离、迪米特、开闭原则等等基本原则；那么，在架构设计方面是否也有类似的基本原则呢？</p>
<a id="more"></a>
<p><strong>什么是架构</strong></p>
<p>关于什么是架构，业界从来没有一个统一的定义。我最欣赏的 Martin Fowler在《企业应用架构模式》给架构定义的核心特征：</p>
<p><strong><em>最高层次的系统分解；</em></strong><br><strong><em>系统中不易改变的决定。</em></strong></p>
<p>而架构的概念最初来源于建筑，因此，我想从建筑的角度去思考这个问题。Wikipedia中，对架构，即Architecture的定义如下：</p>
<p><em>Architecture is both the process and the product of planning, designing, and constructing buildings and other physical structures.</em></p>
<p>从上面的定义中可知，首先，架构的最终目标是为了产出建筑物或其他物理构筑物，构筑物可以只是一套房子，也可以是一栋楼盘，抑或是一个小区、商业区，甚至是一个城市。构筑物越大，其架构必然也越复杂。</p>
<p>其次，产出建筑物之前需要经过三个阶段：规划(planning)、设计(designing)和构建(constructing)。这三个阶段其实也是架构的核心了。比如，开发商要建一个住宅小区，首先肯定要对该小区有一个整体的规划吧：小区的建设选址、建设的规模、建设的内容、投资估算、建设周期等等。接着，就要对小区的各方面进行设计了，最高层次的应该是小区的总体布局设计，拆分开的话就是各楼盘的设计、绿化的设计、各种配套设施的设计等等，再细化下去就是各种户型的设计、楼盘内和小区内各种走道的设计等等。最后，构建阶段也就是施工阶段了，是将之前所有的想法转为实际的建筑物的阶段。</p>
<p>最后，架构包含了以上的过程和结果。也就是说，对小区总体规划的过程是架构，规划的结果方案也是架构，小区总体布局的设计、楼盘的设计、户型的设计等等的每个过程也都是架构，每个过程产出的设计方案也是架构，构建阶段的施工图也是架构，可以说，产出建筑物期间的每个过程和结果都是架构。</p>
<p>那么，如果将建筑物换成了软件，那就变成对软件架构的定义了：软件架构是规划、设计和构建软件的过程和结果。</p>
<p>相应地，软件架构的最终目标就是为了产出软件，可以是一个App，也可以是一个平台，如SaaS、PaaS、BaaS等等，甚至还可以是智慧城市这样庞大的生态系统，地球人都知道，越庞大复杂的系统，架构越难。规划阶段更多考虑的是软件的需求，包括业务上的功能性需求和技术上的非功能性需求，如可靠性、可扩展性、可维护性等；此阶段的架构一般为系统架构。设计阶段的工作更多的就是拆分细化，以满足各种需求；此阶段的架构一般为逻辑架构。构建阶段主要就是对软件的实现和部署了；此阶段的架构一般为物理架构。</p>
<p><strong>架构规划</strong></p>
<p>架构规划做什么呢？我觉得主要是规划好下个阶段架构设计的边界。而影响架构边界的，其实就是需求。需求形成了对架构的约束条件，从而也对架构设计形成了边界。那么，有哪些需求呢？可以分为三大类：商业需求、功能需求和质量需求。</p>
<p><strong>商业需求</strong></p>
<p>商业需求是最高层次的需求，它关注从客户群、企业现状、未来发展、预算、立项、开发、运营、维护在内的整个软件生命周期涉及的商业因素，包括了商业层面的目标、期望和限制等。商业需求一般对架构的影响比较大，对架构产生限制的商业因素也比较多，在此列举一些比较常见的：</p>
<p><strong><em>1.上线时间：</em></strong>上线时间限定了系统从设计、开发、测试到上线的时间边界。架构师需要根据留给开发人员时间长短，平衡各方面需求，做好架构选型。<br><strong><em>2.人力现状：</em></strong>100人的开发团队和5人的开发团队，软件的架构会有很大不同。另外，开发团队人员所掌握的技术也会对架构选型有影响。例如，团队里还没有人会用React Native，那现阶段就不适合选择React Native作为App架构的技术基础。<br><strong><em>3.与外围系统的集成：</em></strong>当需要与外围系统集成时，需要认真考虑集成方法，尤其是外围系统比较老的时候，集成难度可能更高。另外，外围系统的不可控因素一般也比较多，因此，对架构处理这些不可控风险的要求相对也高。<br><strong><em>4.开放性：</em></strong>封闭的私有系统和开放式系统对架构的要求也不同，一个系统如果选择了开放，那对架构的质量要求更高，对安全性、扩展性、性能等质量属性都应该比封闭时高。<br><strong><em>5.目标市场：</em></strong>目标用户1万、100万、1000万，不同级别的目标市场，架构也是大有不同。另外，大众市场和垂直的专门市场，架构也同样有区别，较大的专门市场一般都采用产品线的规划方案。<br><strong><em>6.多端支持：</em></strong>现在移动端普遍支持Android、iOS、Wechat，管理端通常则支持PC Web，如果管理端也要支持Android、iOS、Wechat，或者移动端和管理端还要再支持WindowsPhone、黑莓，甚至再支持VR，则需要投入更多时间和人力，架构上相应也需要做出调整。<br><strong><em>7.期望的系统生存期：</em></strong>从主观上说，谁都希望自己的系统可以生存很久，但生存期越长，意味着系统的可修改性、可扩展性、可移植性等需要更高。但是，受上市时间、成本预算等因素的制约，再加上软件本身的变化快，所以，客观上，一般也不会期望其生存期太长。当系统不能满足渐增的需求时，基本通过重构来解决。<br><strong><em>8.阶段性计划：</em></strong>每一个大平台系统普遍都是分阶段完成的，因此，前期阶段的架构设计时就需要考虑好重用性、扩展性、伸缩性、移植性等特性。但因为每个阶段经过市场验证后，需求有可能会变化，所以又不能过度设计，否则就会造成设计浪费，还可能加大了后续阶段架构调整的难度。<br><strong><em>9.国际化：</em></strong>如果走国际化路线，那架构上就要考虑好对多国语言的支持。<br><strong><em>10.竞争对手：</em></strong>产品要比竞争对手优秀，那就要在一些关键的功能或质量上超越对方，也意味着在这些方面的架构需要投入更多。<br><strong><em>11.法律法规：</em></strong>比如，对某些关键字要进行过滤屏蔽，这是天朝独有的，大家懂的。</p>
<p>商业需求多种多样，有些需求还可能会相互矛盾，比如，上市时间和成本预算就会和期望的系统生存期可能产生矛盾，期望的生存期越长其成本就会越高，需要投入的时间就会越多，那么，就有可能拖延上市时间。因此，做架构规划时，必须梳理清楚哪些需求是能够被满足的，能被满足的程度如何，需要在各个需求间权衡利弊。另外，商业需求因为是最高层次的需求，因此，相对于功能需求和质量需求，其优先级一般也比较高。</p>
<p><strong>功能需求</strong></p>
<p>功能需求描述了系统应该提供的服务，包括为用户提供的服务，也包括为其他系统提供的服务。功能需求基本与具体的业务相关。因此，要做好功能需求这块的架构，就必须对该业务领域足够了解，这样才能更好地抽象建模。</p>
<p>而对功能需求进行领域建模之前，还需先梳理下需求的优先级。因为受商业需求的影响，功能需求也需要权衡。比如，上市时间紧、成本预算低、人力资源也不是很充足的情况下，功能需求只能少不能多。而需要与外围系统集成的时候，也意味着这部分功能不需要自己实现了；但是，如果外围系统无法完全满足需求时，则还需要自己再实现缺失的需求。因此，现阶段需要满足哪些功能需求？需要满足到什么程度？这两个问题确定了之后才能更有效地进行领域建模。</p>
<p><strong>质量需求</strong></p>
<p>质量需求是三类需求中，需求层次最低的，但却是大部分架构师最关注的。纵览那么多架构技术，就会发现，大部分都是为了解决某个或某些质量属性优化的问题。</p>
<p>质量属性常见的有以下这些：</p>
<p><strong><em>1.性能(Performance)：</em></strong>性能无疑是一个非常重要的特性，尤其在计算资源有限的情况下。但也无需过分追求高性能，从而牺牲其他更重要的特性。<br><strong><em>2.安全性(Security)：</em></strong>安全性一般会和性能相互制约，最明显的例子就是HTTPS，使用HTTPS提高了安全性，但性能就会有所牺牲。很难做到既满足高安全又高性能，因此需要根据具体需求平衡两方面的特性。<br><strong><em>3.可用性(Availability)：</em></strong>也有人称为有效性，一般定义为：可用性 = 系统正常工作时间 / (系统正常工作时间 + 故障维修时间）。此定义就说明了可用性与系统故障有关，故障率高，可用性就低，故障率低，可用性才高。另外，高可用性还说明了系统对故障维修的时间也很短。<br><strong><em>4.易用性(Usability)：</em></strong>易用性很容易和可用性混淆，可用性关注的是系统长时间无故障运行的能力，而易用性关注的则是系统易于使用的能力。<br><strong><em>5.鲁棒性(Robustness)：</em></strong>也称为健壮性、容错性，是指系统在出现了用户非法操作、或软硬件的缺陷导致的异常情况下，系统依然能够正常运行的能力。比如说，系统在输入错误、磁盘故障、网络过载或有意攻击情况下，能否不死机、不崩溃，就是该软件的鲁棒性。<br><strong><em>6.可伸缩性(Scalability)：</em></strong>可伸缩性是指当用户量和数据量增加时，系统维持高服务质量的能力。比如，当并发量为1W时，系统响应时间为1秒，那如果并发量增加到100W时，只要通过增加服务器数量，而无需对代码进行修改即可达到系统响应时间依然为1秒，就说明该系统的可伸缩性高。<br><strong><em>7.互操作性(Interoperability)：</em></strong>互操作性反映了本系统与其他系统交换数据和服务的难易程度。<br><strong><em>8.可扩展性(Extensibility)：</em></strong>也称为灵活性，反映了系统应对变化的能力。在软件开发过程中，需求变更是常有的事，尤其在移动互联网时代，变化是非常频繁的，也因此，可扩展性是移动互联网产品重点考虑的质量需求。<br><strong><em>9.可理解性(Understandability)：</em></strong>可理解性是指开发人员通过源代码和相关文档，了解程序功能、结构和运行方式的难易程度。遵从好的开发规范一般都可以提高可理解性。另外，单一职责原则运用得好，也能大大提高可理解性，所谓“简单就是美”，简单才容易理解。<br><strong><em>10.可测试性(Testability)：</em></strong>简单点说，可测试性就是测试和诊断软件错误的难易程度。比如进行单元测试的难易程度。如果程序包含了复杂的处理逻辑、数据结构、模块关系，可测试性的设计更显得尤为重要。<br><strong><em>11.可复用性(Reusability)：</em></strong>可重用性表明了一个软件组件可以在其他程序中使用的难易程度。一般需要将一个组件抽离成通用性的组件时，对可复用性的要求就会比较高。<br><strong><em>12.可移植性(Portability)：</em></strong>可移植性表明了将软件系统从一个运行环境转移到另一个不同的运行环境的难易程度。<br><strong><em>13.可维护性(Maintainability)：</em></strong>可维护性是指理解、改正、改动、改进软件的难易程度。我觉得，可维护性是保证一个软件系统能够长期生存的最重要的特性，没有之一。对一个可维护性差的系统，久而久之，不断变得牵一发而动全身，变得不可维护，慢慢只能宣布灭亡。</p>
<p>理想情况下，谁都希望所有属性都是高质量的，但谁都清楚这是不可能的事。要提高更多质量属性，实现的难度更大，需要付出的成本更高。而且，不同质量属性之间还存在制约关系，比如，提高安全性，一般就会减低性能；提高了性能，还可能减低了可维护性。因此，在实际做架构规划时，必须根据具体需求在各质量属性间权衡优先级。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在思考架构方面一些最基本的问题，比如什么是架构？如何评价一个架构的好坏？是否有一些通用的基本原则指引架构设计？在面向对象设计方面，有单一职责、里氏替换、依赖倒置、接口隔离、迪米特、开闭原则等等基本原则；那么，在架构设计方面是否也有类似的基本原则呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="架构" scheme="http://manongtalk.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>代理模式（Proxy Pattern）</title>
    <link href="http://manongtalk.com/2016/10/05/2016-10-05-proxy/"/>
    <id>http://manongtalk.com/2016/10/05/2016-10-05-proxy/</id>
    <published>2016-10-06T03:45:54.000Z</published>
    <updated>2016-11-13T03:05:38.169Z</updated>
    
    <content type="html"><![CDATA[<p><strong>概念</strong></p>
<p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。<br><a id="more"></a><br><em>意图：</em>为其他对象提供一种代理以控制对这个对象的访问。<br><em>主要解决：</em>在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。<br><em>何时使用：</em>想在访问一个类时做一些控制。<br><em>如何解决：</em>增加中间层。<br><em>关键代码：</em>实现与被代理类组合。<br><em>优点：</em><br>1、职责清晰。<br>2、高扩展性。<br>3、智能化。<br><em>缺点：</em><br>1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。<br>2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。<br><em>使用场景：</em>按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。<br><em>注意事项：</em><br>1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。<br>2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</p>
<p>我们将创建一个 Image 接口和实现了 Image 接口的实体类。ProxyImage 是一个代理类，减少 RealImage 对象加载的内存占用。<br>ProxyPatternDemo，我们的演示类使用 ProxyImage 来获取要加载的 Image 对象，并按照需求进行显示。</p>
<p><img src="https://raw.githubusercontent.com/kylelua/manongtalk/master/img/2016-10-05-proxy/proxy.jpg" alt=""></p>
<p>创建一个接口。<br>Image.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Image &#123;</div><div class="line">   void display();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>步骤 2<br>创建实现接口的实体类。<br>RealImage.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class RealImage implements Image &#123;</div><div class="line"></div><div class="line">   private String fileName;</div><div class="line"></div><div class="line">   public RealImage(String fileName)&#123;</div><div class="line">      this.fileName = fileName;</div><div class="line">      loadFromDisk(fileName);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void display() &#123;</div><div class="line">      System.out.println(&quot;Displaying &quot; + fileName);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private void loadFromDisk(String fileName)&#123;</div><div class="line">      System.out.println(&quot;Loading &quot; + fileName);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ProxyImage.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class ProxyImage implements Image&#123;</div><div class="line"></div><div class="line">   private RealImage realImage;</div><div class="line">   private String fileName;</div><div class="line"></div><div class="line">   public ProxyImage(String fileName)&#123;</div><div class="line">      this.fileName = fileName;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void display() &#123;</div><div class="line">      if(realImage == null)&#123;</div><div class="line">         realImage = new RealImage(fileName);</div><div class="line">      &#125;</div><div class="line">      realImage.display();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当被请求时，使用 ProxyImage 来获取 RealImage 类的对象。<br>ProxyPatternDemo.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class ProxyPatternDemo &#123;</div><div class="line">   </div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Image image = new ProxyImage(&quot;test_10mb.jpg&quot;);</div><div class="line"></div><div class="line">      //图像将从磁盘加载</div><div class="line">      image.display(); </div><div class="line">      System.out.println(&quot;&quot;);</div><div class="line">      //图像将无法从磁盘加载</div><div class="line">      image.display();  </div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>验证输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Loading test_10mb.jpg</div><div class="line">Displaying test_10mb.jpg</div><div class="line"></div><div class="line">Displaying test_10mb.jpg</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。&lt;br&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://manongtalk.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>外观模式（Facade Pattern）</title>
    <link href="http://manongtalk.com/2016/10/05/2016-10-05-facade/"/>
    <id>http://manongtalk.com/2016/10/05/2016-10-05-facade/</id>
    <published>2016-10-06T03:26:02.000Z</published>
    <updated>2016-11-13T03:05:10.585Z</updated>
    
    <content type="html"><![CDATA[<p><strong>概念</strong></p>
<p>外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。<a id="more"></a><br>这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。</p>
<p><em>意图：</em>为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br><em>主要解决：</em>降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。<br><em>何时使用：</em><br>1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个”接待员”即可。<br>2、定义系统的入口。<br><em>如何解决：</em>客户端不与系统耦合，外观类与系统耦合。<br><em>关键代码：</em>在客户端和复杂系统之间再加一层，这一次将调用顺序、依赖关系等处理好。</p>
<p><em>优点：</em><br>1、减少系统相互依赖。<br>2、提高灵活性。<br>3、提高了安全性。<br><em>缺点：</em>不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。<br><em>使用场景：</em><br>1、为复杂的模块或子系统提供外界访问的模块。<br>2、子系统相对独立。<br>3、预防低水平人员带来的风险。<br><em>注意事项：</em>在层次化结构中，可以使用外观模式定义系统中每一层的入口。</p>
<p><strong>实现</strong></p>
<p>我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。下一步是定义一个外观类 ShapeMaker。<br>ShapeMaker 类使用实体类来代表用户对这些类的调用。FacadePatternDemo，我们的演示类使用 ShapeMaker 类来显示结果。</p>
<p><img src="https://raw.githubusercontent.com/kylelua/manongtalk/master/img/2016-10-05-facade/facade.jpg" alt=""></p>
<p>创建一个接口。<br>Shape.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Shape &#123;</div><div class="line">   void draw();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建实现接口的实体类。<br>Rectangle.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Rectangle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Rectangle::draw()&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Square.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Square implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Square::draw()&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Circle.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Circle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Circle::draw()&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建一个外观类。<br>ShapeMaker.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class ShapeMaker &#123;</div><div class="line">   private Shape circle;</div><div class="line">   private Shape rectangle;</div><div class="line">   private Shape square;</div><div class="line"></div><div class="line">   public ShapeMaker() &#123;</div><div class="line">      circle = new Circle();</div><div class="line">      rectangle = new Rectangle();</div><div class="line">      square = new Square();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void drawCircle()&#123;</div><div class="line">      circle.draw();</div><div class="line">   &#125;</div><div class="line">   public void drawRectangle()&#123;</div><div class="line">      rectangle.draw();</div><div class="line">   &#125;</div><div class="line">   public void drawSquare()&#123;</div><div class="line">      square.draw();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用该外观类画出各种类型的形状。<br>FacadePatternDemo.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class FacadePatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      ShapeMaker shapeMaker = new ShapeMaker();</div><div class="line"></div><div class="line">      shapeMaker.drawCircle();</div><div class="line">      shapeMaker.drawRectangle();</div><div class="line">      shapeMaker.drawSquare();		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>验证输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Circle::draw()</div><div class="line">Rectangle::draw()</div><div class="line">Square::draw()</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。
    
    </summary>
    
    
      <category term="设计模式" scheme="http://manongtalk.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>装饰器模式（Decorator Pattern）</title>
    <link href="http://manongtalk.com/2016/09/19/2016-09-19-decorate/"/>
    <id>http://manongtalk.com/2016/09/19/2016-09-19-decorate/</id>
    <published>2016-09-19T19:33:07.000Z</published>
    <updated>2016-11-13T03:04:11.209Z</updated>
    
    <content type="html"><![CDATA[<p><strong>概念</strong></p>
<p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。<br><a id="more"></a><br><em>意图：</em>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。<br><em>主要解决：</em>一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。<br><em>何时使用：</em>在不想增加很多子类的情况下扩展类。<br><em>如何解决：</em>将具体功能职责划分，同时继承装饰者模式。<br><em>关键代码：</em><br>1、Component 类充当抽象角色，不应该具体实现。<br>2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。</p>
<p><em>优点：</em>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。<br><em>缺点：</em>多层装饰比较复杂。<br><em>使用场景：</em><br>1、扩展一个类的功能。<br>2、动态增加功能，动态撤销。<br><em>注意事项：</em>可代替继承。</p>
<p><strong>实现</strong></p>
<p>我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。然后我们创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。RedShapeDecorator 是实现了 ShapeDecorator 的实体类。</p>
<p>DecoratorPatternDemo，我们的演示类使用 RedShapeDecorator 来装饰 Shape 对象。</p>
<p><img src="https://raw.githubusercontent.com/kylelua/manongtalk/master/img/2016-09-19-decorate/decorator.png" alt=""></p>
<p>创建一个接口。<br>Shape.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Shape &#123;</div><div class="line">   void draw();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建实现接口的实体类。<br>Rectangle.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Rectangle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Shape: Rectangle&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Circle.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Circle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Shape: Circle&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建实现了 Shape 接口的抽象装饰类。<br>ShapeDecorator.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public abstract class ShapeDecorator implements Shape &#123;</div><div class="line">   protected Shape decoratedShape;</div><div class="line"></div><div class="line">   public ShapeDecorator(Shape decoratedShape)&#123;</div><div class="line">      this.decoratedShape = decoratedShape;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void draw()&#123;</div><div class="line">      decoratedShape.draw();</div><div class="line">   &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建扩展了 ShapeDecorator 类的实体装饰类。<br>RedShapeDecorator.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class RedShapeDecorator extends ShapeDecorator &#123;</div><div class="line"></div><div class="line">   public RedShapeDecorator(Shape decoratedShape) &#123;</div><div class="line">      super(decoratedShape);     </div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      decoratedShape.draw();         </div><div class="line">      setRedBorder(decoratedShape);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private void setRedBorder(Shape decoratedShape)&#123;</div><div class="line">      System.out.println(&quot;Border Color: Red&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用 RedShapeDecorator 来装饰 Shape 对象。<br>DecoratorPatternDemo.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class DecoratorPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      Shape circle = new Circle();</div><div class="line"></div><div class="line">      Shape redCircle = new RedShapeDecorator(new Circle());</div><div class="line"></div><div class="line">      Shape redRectangle = new RedShapeDecorator(new Rectangle());</div><div class="line">      System.out.println(&quot;Circle with normal border&quot;);</div><div class="line">      circle.draw();</div><div class="line"></div><div class="line">      System.out.println(&quot;\nCircle of red border&quot;);</div><div class="line">      redCircle.draw();</div><div class="line"></div><div class="line">      System.out.println(&quot;\nRectangle of red border&quot;);</div><div class="line">      redRectangle.draw();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>验证输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Circle with normal border</div><div class="line">Shape: Circle</div><div class="line"></div><div class="line">Circle of red border</div><div class="line">Shape: Circle</div><div class="line">Border Color: Red</div><div class="line"></div><div class="line">Rectangle of red border</div><div class="line">Shape: Rectangle</div><div class="line">Border Color: Red</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。&lt;br&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://manongtalk.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>组合模式（Composite Pattern）</title>
    <link href="http://manongtalk.com/2016/09/19/2016-09-19-composite/"/>
    <id>http://manongtalk.com/2016/09/19/2016-09-19-composite/</id>
    <published>2016-09-19T14:19:19.000Z</published>
    <updated>2016-11-13T03:03:29.901Z</updated>
    
    <content type="html"><![CDATA[<p><strong>概念</strong></p>
<p>组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。我们通过下面的实例来演示组合模式的用法。实例演示了一个组织中员工的层次结构。<br><a id="more"></a><br><em>意图：</em>将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。<br><em>主要解决：</em>它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。<br><em>何时使用：</em><br>1、您想表示对象的部分-整体层次结构（树形结构）。<br>2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。<br><em>如何解决：</em>树枝和叶子实现统一接口，树枝内部组合该接口。<br><em>关键代码：</em>树枝内部组合该接口，并且含有内部属性 List，里面放 Component。</p>
<p><em>优点：</em><br>1、高层模块调用简单。<br>2、节点自由增加。<br><em>缺点：</em>在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。<br><em>使用场景：</em>部分、整体场景，如树形菜单，文件、文件夹的管理。<br><em>注意事项：</em>定义时为具体类。</p>
<p><strong>实现</strong></p>
<p>我们有一个类 Employee，该类被当作组合模型类。CompositePatternDemo，我们的演示类使用 Employee 类来添加部门层次结构，并打印所有员工。</p>
<p><img src="https://raw.githubusercontent.com/kylelua/manongtalk/master/img/2016-09-19-composite/composite.png" alt=""></p>
<p>创建 Employee 类，该类带有 Employee 对象的列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">Employee.java</div><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class Employee &#123;</div><div class="line">   private String name;</div><div class="line">   private String dept;</div><div class="line">   private int salary;</div><div class="line">   private List&lt;Employee&gt; subordinates;</div><div class="line"></div><div class="line">   //构造函数</div><div class="line">   public Employee(String name,String dept, int sal) &#123;</div><div class="line">      this.name = name;</div><div class="line">      this.dept = dept;</div><div class="line">      this.salary = sal;</div><div class="line">      subordinates = new ArrayList&lt;Employee&gt;();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void add(Employee e) &#123;</div><div class="line">      subordinates.add(e);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void remove(Employee e) &#123;</div><div class="line">      subordinates.remove(e);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public List&lt;Employee&gt; getSubordinates()&#123;</div><div class="line">     return subordinates;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String toString()&#123;</div><div class="line">      return (&quot;Employee :[ Name : &quot;+ name </div><div class="line">      +&quot;, dept : &quot;+ dept + &quot;, salary :&quot;</div><div class="line">      + salary+&quot; ]&quot;);</div><div class="line">   &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用 Employee 类来创建和打印员工的层次结构。<br>CompositePatternDemo.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class CompositePatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Employee CEO = new Employee(&quot;John&quot;,&quot;CEO&quot;, 30000);</div><div class="line"></div><div class="line">      Employee headSales = new Employee(&quot;Robert&quot;,&quot;Head Sales&quot;, 20000);</div><div class="line"></div><div class="line">      Employee headMarketing = new Employee(&quot;Michel&quot;,&quot;Head Marketing&quot;, 20000);</div><div class="line"></div><div class="line">      Employee clerk1 = new Employee(&quot;Laura&quot;,&quot;Marketing&quot;, 10000);</div><div class="line">      Employee clerk2 = new Employee(&quot;Bob&quot;,&quot;Marketing&quot;, 10000);</div><div class="line"></div><div class="line">      Employee salesExecutive1 = new Employee(&quot;Richard&quot;,&quot;Sales&quot;, 10000);</div><div class="line">      Employee salesExecutive2 = new Employee(&quot;Rob&quot;,&quot;Sales&quot;, 10000);</div><div class="line"></div><div class="line">      CEO.add(headSales);</div><div class="line">      CEO.add(headMarketing);</div><div class="line"></div><div class="line">      headSales.add(salesExecutive1);</div><div class="line">      headSales.add(salesExecutive2);</div><div class="line"></div><div class="line">      headMarketing.add(clerk1);</div><div class="line">      headMarketing.add(clerk2);</div><div class="line"></div><div class="line">      //打印该组织的所有员工</div><div class="line">      System.out.println(CEO); </div><div class="line">      for (Employee headEmployee : CEO.getSubordinates()) &#123;</div><div class="line">         System.out.println(headEmployee);</div><div class="line">         for (Employee employee : headEmployee.getSubordinates()) &#123;</div><div class="line">            System.out.println(employee);</div><div class="line">         &#125;</div><div class="line">      &#125;		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>验证输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Employee :[ Name : John, dept : CEO, salary :30000 ]</div><div class="line">Employee :[ Name : Robert, dept : Head Sales, salary :20000 ]</div><div class="line">Employee :[ Name : Richard, dept : Sales, salary :10000 ]</div><div class="line">Employee :[ Name : Rob, dept : Sales, salary :10000 ]</div><div class="line">Employee :[ Name : Michel, dept : Head Marketing, salary :20000 ]</div><div class="line">Employee :[ Name : Laura, dept : Marketing, salary :10000 ]</div><div class="line">Employee :[ Name : Bob, dept : Marketing, salary :10000 ]</div></pre></td></tr></table></figure></p>
<p><strong>应用实例</strong><br>1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作树、操作符和另一个操作数。<br>2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。我们通过下面的实例来演示组合模式的用法。实例演示了一个组织中员工的层次结构。&lt;br&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://manongtalk.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）</title>
    <link href="http://manongtalk.com/2016/09/18/2016-09-16-filter/"/>
    <id>http://manongtalk.com/2016/09/18/2016-09-16-filter/</id>
    <published>2016-09-19T02:56:38.000Z</published>
    <updated>2016-11-13T03:02:27.605Z</updated>
    
    <content type="html"><![CDATA[<p><strong>概念</strong><br>过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。<br><a id="more"></a><br><strong>实现</strong><br>我们将创建一个 Person 对象、Criteria 接口和实现了该接口的实体类，来过滤 Person 对象的列表。CriteriaPatternDemo，我们的演示类使用 Criteria 对象，基于各种标准和它们的结合来过滤 Person 对象的列表。</p>
<p><img src="https://raw.githubusercontent.com/kylelua/manongtalk/master/img/2016-09-16-filter/filter.png" alt=""></p>
<p>创建一个类，在该类上应用标准。<br>Person.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class Person &#123;</div><div class="line">   </div><div class="line">   private String name;</div><div class="line">   private String gender;</div><div class="line">   private String maritalStatus;</div><div class="line"></div><div class="line">   public Person(String name,String gender,String maritalStatus)&#123;</div><div class="line">      this.name = name;</div><div class="line">      this.gender = gender;</div><div class="line">      this.maritalStatus = maritalStatus;    </div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String getName() &#123;</div><div class="line">      return name;</div><div class="line">   &#125;</div><div class="line">   public String getGender() &#123;</div><div class="line">      return gender;</div><div class="line">   &#125;</div><div class="line">   public String getMaritalStatus() &#123;</div><div class="line">      return maritalStatus;</div><div class="line">   &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为标准（Criteria）创建一个接口。<br>Criteria.java<br>import java.util.List;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Criteria &#123;</div><div class="line">   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建实现了 Criteria 接口的实体类。<br>CriteriaMale.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class CriteriaMale implements Criteria &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123;</div><div class="line">      List&lt;Person&gt; malePersons = new ArrayList&lt;Person&gt;(); </div><div class="line">      for (Person person : persons) &#123;</div><div class="line">         if(person.getGender().equalsIgnoreCase(&quot;MALE&quot;))&#123;</div><div class="line">            malePersons.add(person);</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      return malePersons;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>CriteriaFemale.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class CriteriaFemale implements Criteria &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123;</div><div class="line">      List&lt;Person&gt; femalePersons = new ArrayList&lt;Person&gt;(); </div><div class="line">      for (Person person : persons) &#123;</div><div class="line">         if(person.getGender().equalsIgnoreCase(&quot;FEMALE&quot;))&#123;</div><div class="line">            femalePersons.add(person);</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      return femalePersons;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>CriteriaSingle.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class CriteriaSingle implements Criteria &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123;</div><div class="line">      List&lt;Person&gt; singlePersons = new ArrayList&lt;Person&gt;(); </div><div class="line">      for (Person person : persons) &#123;</div><div class="line">         if(person.getMaritalStatus().equalsIgnoreCase(&quot;SINGLE&quot;))&#123;</div><div class="line">            singlePersons.add(person);</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      return singlePersons;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>AndCriteria.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class AndCriteria implements Criteria &#123;</div><div class="line"></div><div class="line">   private Criteria criteria;</div><div class="line">   private Criteria otherCriteria;</div><div class="line"></div><div class="line">   public AndCriteria(Criteria criteria, Criteria otherCriteria) &#123;</div><div class="line">      this.criteria = criteria;</div><div class="line">      this.otherCriteria = otherCriteria; </div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123;</div><div class="line">      List&lt;Person&gt; firstCriteriaPersons = criteria.meetCriteria(persons);     </div><div class="line">      return otherCriteria.meetCriteria(firstCriteriaPersons);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>OrCriteria.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class OrCriteria implements Criteria &#123;</div><div class="line"></div><div class="line">   private Criteria criteria;</div><div class="line">   private Criteria otherCriteria;</div><div class="line"></div><div class="line">   public OrCriteria(Criteria criteria, Criteria otherCriteria) &#123;</div><div class="line">      this.criteria = criteria;</div><div class="line">      this.otherCriteria = otherCriteria; </div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123;</div><div class="line">      List&lt;Person&gt; firstCriteriaItems = criteria.meetCriteria(persons);</div><div class="line">      List&lt;Person&gt; otherCriteriaItems = otherCriteria.meetCriteria(persons);</div><div class="line"></div><div class="line">      for (Person person : otherCriteriaItems) &#123;</div><div class="line">         if(!firstCriteriaItems.contains(person))&#123;</div><div class="line">           firstCriteriaItems.add(person);</div><div class="line">         &#125;</div><div class="line">      &#125;  </div><div class="line">      return firstCriteriaItems;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用不同的标准（Criteria）和它们的结合来过滤 Person 对象的列表。<br>CriteriaPatternDemo.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList; </div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class CriteriaPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      List&lt;Person&gt; persons = new ArrayList&lt;Person&gt;();</div><div class="line"></div><div class="line">      persons.add(new Person(&quot;Robert&quot;,&quot;Male&quot;, &quot;Single&quot;));</div><div class="line">      persons.add(new Person(&quot;John&quot;,&quot;Male&quot;, &quot;Married&quot;));</div><div class="line">      persons.add(new Person(&quot;Laura&quot;,&quot;Female&quot;, &quot;Married&quot;));</div><div class="line">      persons.add(new Person(&quot;Diana&quot;,&quot;Female&quot;, &quot;Single&quot;));</div><div class="line">      persons.add(new Person(&quot;Mike&quot;,&quot;Male&quot;, &quot;Single&quot;));</div><div class="line">      persons.add(new Person(&quot;Bobby&quot;,&quot;Male&quot;, &quot;Single&quot;));</div><div class="line"></div><div class="line">      Criteria male = new CriteriaMale();</div><div class="line">      Criteria female = new CriteriaFemale();</div><div class="line">      Criteria single = new CriteriaSingle();</div><div class="line">      Criteria singleMale = new AndCriteria(single, male);</div><div class="line">      Criteria singleOrFemale = new OrCriteria(single, female);</div><div class="line"></div><div class="line">      System.out.println(&quot;Males: &quot;);</div><div class="line">      printPersons(male.meetCriteria(persons));</div><div class="line"></div><div class="line">      System.out.println(&quot;\nFemales: &quot;);</div><div class="line">      printPersons(female.meetCriteria(persons));</div><div class="line"></div><div class="line">      System.out.println(&quot;\nSingle Males: &quot;);</div><div class="line">      printPersons(singleMale.meetCriteria(persons));</div><div class="line"></div><div class="line">      System.out.println(&quot;\nSingle Or Females: &quot;);</div><div class="line">      printPersons(singleOrFemale.meetCriteria(persons));</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public static void printPersons(List&lt;Person&gt; persons)&#123;</div><div class="line">      for (Person person : persons) &#123;</div><div class="line">         System.out.println(&quot;Person : [ Name : &quot; + person.getName() </div><div class="line">            +&quot;, Gender : &quot; + person.getGender() </div><div class="line">            +&quot;, Marital Status : &quot; + person.getMaritalStatus()</div><div class="line">            +&quot; ]&quot;);</div><div class="line">      &#125;</div><div class="line">   &#125;      </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>验证输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Males: </div><div class="line">Person : [ Name : Robert, Gender : Male, Marital Status : Single ]</div><div class="line">Person : [ Name : John, Gender : Male, Marital Status : Married ]</div><div class="line">Person : [ Name : Mike, Gender : Male, Marital Status : Single ]</div><div class="line">Person : [ Name : Bobby, Gender : Male, Marital Status : Single ]</div><div class="line"></div><div class="line">Females: </div><div class="line">Person : [ Name : Laura, Gender : Female, Marital Status : Married ]</div><div class="line">Person : [ Name : Diana, Gender : Female, Marital Status : Single ]</div><div class="line"></div><div class="line">Single Males: </div><div class="line">Person : [ Name : Robert, Gender : Male, Marital Status : Single ]</div><div class="line">Person : [ Name : Mike, Gender : Male, Marital Status : Single ]</div><div class="line">Person : [ Name : Bobby, Gender : Male, Marital Status : Single ]</div><div class="line"></div><div class="line">Single Or Females: </div><div class="line">Person : [ Name : Robert, Gender : Male, Marital Status : Single ]</div><div class="line">Person : [ Name : Diana, Gender : Female, Marital Status : Single ]</div><div class="line">Person : [ Name : Mike, Gender : Male, Marital Status : Single ]</div><div class="line">Person : [ Name : Bobby, Gender : Male, Marital Status : Single ]</div><div class="line">Person : [ Name : Laura, Gender : Female, Marital Status : Married ]</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;概念&lt;/strong&gt;&lt;br&gt;过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。&lt;br&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://manongtalk.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>桥接模式（Bridge Pattern）</title>
    <link href="http://manongtalk.com/2016/09/18/2016-09-16-bridge/"/>
    <id>http://manongtalk.com/2016/09/18/2016-09-16-bridge/</id>
    <published>2016-09-19T02:18:30.000Z</published>
    <updated>2016-11-13T02:46:56.553Z</updated>
    
    <content type="html"><![CDATA[<p><strong>概念</strong></p>
<p>桥接模式（Bridge Pattern）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。<br><a id="more"></a><br><strong>用途</strong></p>
<p>我们通过下面的实例来演示桥接模式（Bridge Pattern）的用法。其中，可以使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的圆。</p>
<p><em>意图：</em>将抽象部分与实现部分分离，使它们都可以独立的变化。<br><em>主要解决：</em>在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。<br><em>何时使用：</em>实现系统可能有多个角度分类，每一种角度都可能变化。<br><em>如何解决：</em>把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。<br><em>关键代码：</em>抽象类依赖实现类。</p>
<p><em>优点：</em><br>1、抽象和实现的分离。<br>2、优秀的扩展能力。<br>3、实现细节对客户透明。</p>
<p><em>缺点：</em><br>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</p>
<p><em>使用场景：</em><br>1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。<br>2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。<br>3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。<br><em>注意事项：</em>对于两个独立变化的维度，使用桥接模式再适合不过了。</p>
<p><strong>实现</strong><br>我们有一个作为桥接实现的 DrawAPI 接口和实现了 DrawAPI 接口的实体类 RedCircle、GreenCircle。Shape 是一个抽象类，将使用 DrawAPI 的对象。BridgePatternDemo，我们的演示类使用 Shape 类来画出不同颜色的圆。</p>
<p><img src="https://raw.githubusercontent.com/kylelua/manongtalk/master/img/2016-09-16-bridge/bridge.png" alt=""></p>
<p>创建桥接实现接口。<br>DrawAPI.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface DrawAPI &#123;</div><div class="line">   public void drawCircle(int radius, int x, int y);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建实现了 DrawAPI 接口的实体桥接实现类。<br>RedCircle.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class RedCircle implements DrawAPI &#123;</div><div class="line">   @Override</div><div class="line">   public void drawCircle(int radius, int x, int y) &#123;</div><div class="line">      System.out.println(&quot;Drawing Circle[ color: red, radius: &quot;</div><div class="line">         + radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>GreenCircle.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class GreenCircle implements DrawAPI &#123;</div><div class="line">   @Override</div><div class="line">   public void drawCircle(int radius, int x, int y) &#123;</div><div class="line">      System.out.println(&quot;Drawing Circle[ color: green, radius: &quot;</div><div class="line">         + radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用 DrawAPI 接口创建抽象类 Shape。<br>Shape.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public abstract class Shape &#123;</div><div class="line">   protected DrawAPI drawAPI;</div><div class="line">   protected Shape(DrawAPI drawAPI)&#123;</div><div class="line">      this.drawAPI = drawAPI;</div><div class="line">   &#125;</div><div class="line">   public abstract void draw();  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建实现了 Shape 接口的实体类。<br>Circle.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Circle extends Shape &#123;</div><div class="line">   private int x, y, radius;</div><div class="line"></div><div class="line">   public Circle(int x, int y, int radius, DrawAPI drawAPI) &#123;</div><div class="line">      super(drawAPI);</div><div class="line">      this.x = x;  </div><div class="line">      this.y = y;  </div><div class="line">      this.radius = radius;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void draw() &#123;</div><div class="line">      drawAPI.drawCircle(radius,x,y);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用 Shape 和 DrawAPI 类画出不同颜色的圆。<br>BridgePatternDemo.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class BridgePatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Shape redCircle = new Circle(100,100, 10, new RedCircle());</div><div class="line">      Shape greenCircle = new Circle(100,100, 10, new GreenCircle());</div><div class="line"></div><div class="line">      redCircle.draw();</div><div class="line">      greenCircle.draw();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>验证输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Drawing Circle[ color: red, radius: 10, x: 100, 100]</div><div class="line">Drawing Circle[  color: green, radius: 10, x: 100, 100]</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;桥接模式（Bridge Pattern）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。&lt;br&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://manongtalk.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>原型模式（Prototype Pattern）</title>
    <link href="http://manongtalk.com/2016/09/18/2016-09-16-prototype/"/>
    <id>http://manongtalk.com/2016/09/18/2016-09-16-prototype/</id>
    <published>2016-09-19T01:50:03.000Z</published>
    <updated>2016-11-13T03:02:59.341Z</updated>
    
    <content type="html"><![CDATA[<p><strong>概念</strong><br>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。<br><a id="more"></a><br><em>意图：</em>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。<br><em>主要解决：</em>在运行期建立和删除原型。<br><em>何时使用：</em><br>1、当一个系统应该独立于它的产品创建，构成和表示时。<br>2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。<br>3、为了避免创建一个与产品类层次平行的工厂类层次时。<br>4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</p>
<p><em>如何解决：</em>利用已有的一个原型对象，快速地生成和原型对象一样的实例。<br><em>关键代码：</em><br>1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。<br>2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些”易变类”拥有稳定的接口。</p>
<p><em>优点：</em><br>1、性能提高。<br>2、逃避构造函数的约束。<br><em>缺点：</em><br>1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。<br>2、必须实现 Cloneable 接口。<br>3、逃避构造函数的约束。</p>
<p><em>使用场景：</em><br>1、资源优化场景。<br>2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。<br>3、性能和安全要求的场景。<br>4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。<br>5、一个对象多个修改者的场景。<br>6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。<br>7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。</p>
<p><em>注意事项：</em>与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。</p>
<p><strong>实现</strong><br>我们将创建一个抽象类 Shape 和扩展了 Shape 类的实体类。下一步是定义类 ShapeCache，该类把 shape 对象存储在一个 Hashtable 中，并在请求的时候返回它们的克隆。<br>PrototypPatternDemo，我们的演示类使用 ShapeCache 类来获取 Shape 对象。</p>
<p><img src="https://github.com/kylelua/manongtalk/blob/master/img/2016-09-16-prototype/prototype.png" alt=""></p>
<p>创建一个实现了 Clonable 接口的抽象类。<br>Shape.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public abstract class Shape implements Cloneable &#123;</div><div class="line">   </div><div class="line">   private String id;</div><div class="line">   protected String type;</div><div class="line">   </div><div class="line">   abstract void draw();</div><div class="line">   </div><div class="line">   public String getType()&#123;</div><div class="line">      return type;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   public String getId() &#123;</div><div class="line">      return id;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   public void setId(String id) &#123;</div><div class="line">      this.id = id;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   public Object clone() &#123;</div><div class="line">      Object clone = null;</div><div class="line">      try &#123;</div><div class="line">         clone = super.clone();</div><div class="line">      &#125; catch (CloneNotSupportedException e) &#123;</div><div class="line">         e.printStackTrace();</div><div class="line">      &#125;</div><div class="line">      return clone;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建扩展了上面抽象类的实体类。<br>Rectangle.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Rectangle extends Shape &#123;</div><div class="line"></div><div class="line">   public Rectangle()&#123;</div><div class="line">     type = &quot;Rectangle&quot;;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Square.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Square extends Shape &#123;</div><div class="line"></div><div class="line">   public Square()&#123;</div><div class="line">     type = &quot;Square&quot;;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Square::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Circle.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Circle extends Shape &#123;</div><div class="line"></div><div class="line">   public Circle()&#123;</div><div class="line">     type = &quot;Circle&quot;;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Circle::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建一个类，从数据库获取实体类，并把它们存储在一个 Hashtable 中。<br>ShapeCache.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">import java.util.Hashtable;</div><div class="line"></div><div class="line">public class ShapeCache &#123;</div><div class="line">	</div><div class="line">   private static Hashtable&lt;String, Shape&gt; shapeMap </div><div class="line">      = new Hashtable&lt;String, Shape&gt;();</div><div class="line"></div><div class="line">   public static Shape getShape(String shapeId) &#123;</div><div class="line">      Shape cachedShape = shapeMap.get(shapeId);</div><div class="line">      return (Shape) cachedShape.clone();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // 对每种形状都运行数据库查询，并创建该形状</div><div class="line">   // shapeMap.put(shapeKey, shape);</div><div class="line">   // 例如，我们要添加三种形状</div><div class="line">   public static void loadCache() &#123;</div><div class="line">      Circle circle = new Circle();</div><div class="line">      circle.setId(&quot;1&quot;);</div><div class="line">      shapeMap.put(circle.getId(),circle);</div><div class="line"></div><div class="line">      Square square = new Square();</div><div class="line">      square.setId(&quot;2&quot;);</div><div class="line">      shapeMap.put(square.getId(),square);</div><div class="line"></div><div class="line">      Rectangle rectangle = new Rectangle();</div><div class="line">      rectangle.setId(&quot;3&quot;);</div><div class="line">      shapeMap.put(rectangle.getId(),rectangle);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>PrototypePatternDemo 使用 ShapeCache 类来获取存储在 Hashtable 中的形状的克隆。<br>PrototypePatternDemo.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class PrototypePatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      ShapeCache.loadCache();</div><div class="line"></div><div class="line">      Shape clonedShape = (Shape) ShapeCache.getShape(&quot;1&quot;);</div><div class="line">      System.out.println(&quot;Shape : &quot; + clonedShape.getType());		</div><div class="line"></div><div class="line">      Shape clonedShape2 = (Shape) ShapeCache.getShape(&quot;2&quot;);</div><div class="line">      System.out.println(&quot;Shape : &quot; + clonedShape2.getType());		</div><div class="line"></div><div class="line">      Shape clonedShape3 = (Shape) ShapeCache.getShape(&quot;3&quot;);</div><div class="line">      System.out.println(&quot;Shape : &quot; + clonedShape3.getType());		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>验证输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Shape : Circle</div><div class="line">Shape : Square</div><div class="line">Shape : Rectangle</div></pre></td></tr></table></figure></p>
<p><strong>应用实例</strong><br>1、细胞分裂。<br>2、JAVA 中的 Object clone() 方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;概念&lt;/strong&gt;&lt;br&gt;原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。&lt;br&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://manongtalk.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>适配器模式（Adapter Pattern）</title>
    <link href="http://manongtalk.com/2016/09/18/2016-09-16-adapter/"/>
    <id>http://manongtalk.com/2016/09/18/2016-09-16-adapter/</id>
    <published>2016-09-18T21:51:42.000Z</published>
    <updated>2016-11-13T02:42:43.649Z</updated>
    
    <content type="html"><![CDATA[<p><strong>概念</strong></p>
<p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。<br><a id="more"></a><br><strong>用途</strong></p>
<p>我们通过下面的实例来演示适配器模式的使用。其中，音频播放器设备只能播放 mp3 文件，通过使用一个更高级的音频播放器来播放 vlc 和 mp4 文件。</p>
<p>意图：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br>主要解决：主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。<br>何时使用：<br>1、系统需要使用现有的类，而此类的接口不符合系统的需要。<br>2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。<br>3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）<br>如何解决：继承或依赖（推荐）。<br>关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。</p>
<p>优点：<br>1、可以让任何两个没有关联的类一起运行。<br>2、提高了类的复用。<br>3、增加了类的透明度。<br>4、灵活性好。<br>缺点：<br>1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。<br>2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</p>
<p>使用场景：有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。<br>注意事项：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。</p>
<p><strong>实现方式</strong><br>我们有一个 MediaPlayer 接口和一个实现了 MediaPlayer 接口的实体类 AudioPlayer。默认情况下，AudioPlayer 可以播放 mp3 格式的音频文件。我们还有另一个接口 AdvancedMediaPlayer 和实现了 AdvancedMediaPlayer 接口的实体类。该类可以播放 vlc 和 mp4 格式的文件。我们想要让 AudioPlayer 播放其他格式的音频文件。为了实现这个功能，我们需要创建一个实现了 MediaPlayer 接口的适配器类 MediaAdapter，并使用 AdvancedMediaPlayer 对象来播放所需的格式。AudioPlayer 使用适配器类 MediaAdapter 传递所需的音频类型，不需要知道能播放所需格式音频的实际类。AdapterPatternDemo，我们的演示类使用 AudioPlayer 类来播放各种格式。</p>
<p><img src="https://raw.githubusercontent.com/kylelua/manongtalk/master/img/2016-09-16-adapter/adapter.png" alt=""></p>
<p>为媒体播放器和更高级的媒体播放器创建接口。<br>MediaPlayer.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface MediaPlayer &#123;</div><div class="line">   public void play(String audioType, String fileName);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>AdvancedMediaPlayer.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface AdvancedMediaPlayer &#123;	</div><div class="line">   public void playVlc(String fileName);</div><div class="line">   public void playMp4(String fileName);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建实现了 AdvancedMediaPlayer 接口的实体类。<br>VlcPlayer.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class VlcPlayer implements AdvancedMediaPlayer&#123;</div><div class="line">   @Override</div><div class="line">   public void playVlc(String fileName) &#123;</div><div class="line">      System.out.println(&quot;Playing vlc file. Name: &quot;+ fileName);		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void playMp4(String fileName) &#123;</div><div class="line">      //什么也不做</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Mp4Player.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Mp4Player implements AdvancedMediaPlayer&#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void playVlc(String fileName) &#123;</div><div class="line">      //什么也不做</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void playMp4(String fileName) &#123;</div><div class="line">      System.out.println(&quot;Playing mp4 file. Name: &quot;+ fileName);		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建实现了 MediaPlayer 接口的适配器类。<br>MediaAdapter.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class MediaAdapter implements MediaPlayer &#123;</div><div class="line"></div><div class="line">   AdvancedMediaPlayer advancedMusicPlayer;</div><div class="line"></div><div class="line">   public MediaAdapter(String audioType)&#123;</div><div class="line">      if(audioType.equalsIgnoreCase(&quot;vlc&quot;) )&#123;</div><div class="line">         advancedMusicPlayer = new VlcPlayer();			</div><div class="line">      &#125; else if (audioType.equalsIgnoreCase(&quot;mp4&quot;))&#123;</div><div class="line">         advancedMusicPlayer = new Mp4Player();</div><div class="line">      &#125;	</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void play(String audioType, String fileName) &#123;</div><div class="line">      if(audioType.equalsIgnoreCase(&quot;vlc&quot;))&#123;</div><div class="line">         advancedMusicPlayer.playVlc(fileName);</div><div class="line">      &#125;else if(audioType.equalsIgnoreCase(&quot;mp4&quot;))&#123;</div><div class="line">         advancedMusicPlayer.playMp4(fileName);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建实现了 MediaPlayer 接口的实体类。<br>AudioPlayer.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class AudioPlayer implements MediaPlayer &#123;</div><div class="line">   MediaAdapter mediaAdapter; </div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void play(String audioType, String fileName) &#123;		</div><div class="line"></div><div class="line">      //播放 mp3 音乐文件的内置支持</div><div class="line">      if(audioType.equalsIgnoreCase(&quot;mp3&quot;))&#123;</div><div class="line">         System.out.println(&quot;Playing mp3 file. Name: &quot;+ fileName);			</div><div class="line">      &#125; </div><div class="line">      //mediaAdapter 提供了播放其他文件格式的支持</div><div class="line">      else if(audioType.equalsIgnoreCase(&quot;vlc&quot;) </div><div class="line">         || audioType.equalsIgnoreCase(&quot;mp4&quot;))&#123;</div><div class="line">         mediaAdapter = new MediaAdapter(audioType);</div><div class="line">         mediaAdapter.play(audioType, fileName);</div><div class="line">      &#125;</div><div class="line">      else&#123;</div><div class="line">         System.out.println(&quot;Invalid media. &quot;+</div><div class="line">            audioType + &quot; format not supported&quot;);</div><div class="line">      &#125;</div><div class="line">   &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用 AudioPlayer 来播放不同类型的音频格式。<br>AdapterPatternDemo.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class AdapterPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      AudioPlayer audioPlayer = new AudioPlayer();</div><div class="line"></div><div class="line">      audioPlayer.play(&quot;mp3&quot;, &quot;beyond the horizon.mp3&quot;);</div><div class="line">      audioPlayer.play(&quot;mp4&quot;, &quot;alone.mp4&quot;);</div><div class="line">      audioPlayer.play(&quot;vlc&quot;, &quot;far far away.vlc&quot;);</div><div class="line">      audioPlayer.play(&quot;avi&quot;, &quot;mind me.avi&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>验证输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Playing mp3 file. Name: beyond the horizon.mp3</div><div class="line">Playing mp4 file. Name: alone.mp4</div><div class="line">Playing vlc file. Name: far far away.vlc</div><div class="line">Invalid media. avi format not supported</div></pre></td></tr></table></figure></p>
<p><strong>应用实例</strong> </p>
<ol>
<li>JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 </li>
<li>在 LINUX 上运行 WINDOWS 程序。 </li>
<li>JAVA 中的 jdbc。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。&lt;br&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://manongtalk.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>建造者模式（Builder Pattern）</title>
    <link href="http://manongtalk.com/2016/09/05/2016-09-05-builder/"/>
    <id>http://manongtalk.com/2016/09/05/2016-09-05-builder/</id>
    <published>2016-09-06T02:18:45.000Z</published>
    <updated>2016-11-13T02:38:12.459Z</updated>
    
    <content type="html"><![CDATA[<p><strong>概念</strong></p>
<p>建造者模式（Builder Pattern）是一种创建型设计模式，又名：生成器模式。GOF 给建造者模式的定义为：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。这句话说的比较抽象，其实解释一下就是：<strong>将建造复杂对象的过程和组成对象的部件解耦。</strong><br><a id="more"></a><br><strong>用途</strong></p>
<p>假设现在我们是一家网游设计公司，现在我们要”抄袭”梦幻西游这款游戏，你是该公司的游戏角色设计人员。你怎么设计出该游戏中的各种角色呢？ 在梦幻西游来中包括人、仙、魔等种族的角色，而每种不同的种族的角色中又包含龙太子、逍遥生等具体的角色。</p>
<p>作为一个出色的开发人员，我们设计的角色生成系统应该包含以下功能和特性：</p>
<p><em>为了保证游戏平衡，所有角色的基本属性应该一致
</em>因为角色的创建过程可能很复杂，所以角色的生成细节不应该对外暴露<br><em>随时可以新增角色
</em>对某个具体角色的修改应该不影响其他角色</p>
<p>其实，对于角色的设计，我们可以使用抽象工厂模式，将同一种族的角色看成是一个产品族。但是，这样做可能存在一个问题，那就是我们可能要在每个角色的创建过程中都要从头到尾的构建一遍该角色。比如一个角色包含头部、身体。其中头部又包括脸部、和其他部位。其中脸部又包含眉毛、嘴巴、鼻子等部位。整个角色的创建过程是极其复杂的。很容易遗漏其中的某个步骤。</p>
<p>那么，我们可以将这些具体部位的创建工作和对象的创建进行解耦。这就是建造者模式。</p>
<p><strong>实现方式</strong></p>
<p>建造者模式包含如下角色：</p>
<p>Builder：抽象建造者(Builder)</p>
<p>ConcreteBuilder：具体建造者(CommonBuilder、SuperBuilder)</p>
<p>Director：指挥者(Director)</p>
<p>Product：产品角色(Role)</p>
<p><img src="https://raw.githubusercontent.com/kylelua/manongtalk/master/img/2016-09-05-builder/builder.png" alt=""></p>
<p>这里采用设计角色的例子，为了便于理解，我们只创建两个角色，分别是普通角色和超级角色。他们都有设置头部、脸部、身体、气血值、魔法值、能量值等方法。值得注意的是设置脸部是依赖于设置头部的，要有先后顺序。</p>
<p>产品角色：Role</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Role &#123;</div><div class="line"></div><div class="line">    private String head; //头部</div><div class="line">    private String face; //脸部（脸部依赖于头部）</div><div class="line">    private String body; //身体</div><div class="line">    private Double hp;   //生命值</div><div class="line">    private Double sp;   //能量值</div><div class="line">    private Double mp;   //魔法值</div><div class="line"></div><div class="line">    //setter and getter </div><div class="line">     // toString </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>抽象建造者：Builder</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public abstract class Builder &#123;</div><div class="line"></div><div class="line">    protected Role role = new Role();</div><div class="line"></div><div class="line">    public abstract void buildHead();</div><div class="line"></div><div class="line">    public abstract void buildFace();</div><div class="line"></div><div class="line">    public abstract void buildBody();</div><div class="line"></div><div class="line">    public abstract void buildHp();</div><div class="line"></div><div class="line">    public abstract void buildSp();</div><div class="line"></div><div class="line">    public abstract void buildMp();</div><div class="line"></div><div class="line">    public Role getResult() &#123;</div><div class="line">        return role;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体建造者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">public class CommonRoleBuilder extends Builder &#123;</div><div class="line"></div><div class="line">    private Role role = new Role();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void buildHead() &#123;</div><div class="line">        role.setBody(&quot;common head&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void buildFace() &#123;</div><div class="line">        role.setFace(&quot;common face&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void buildBody() &#123;</div><div class="line">        role.setBody(&quot;common body&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void buildHp() &#123;</div><div class="line">        role.setHp(100d);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void buildSp() &#123;</div><div class="line">        role.setSp(100d);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void buildMp() &#123;</div><div class="line">        role.setMp(100d);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Role getResult() &#123;</div><div class="line">        return role;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class SuperRoleBuilder extends Builder &#123;</div><div class="line"></div><div class="line">    private Role role = new Role();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void buildHead() &#123;</div><div class="line">        role.setBody(&quot;super head&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void buildFace() &#123;</div><div class="line">        role.setFace(&quot;super face&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void buildBody() &#123;</div><div class="line">        role.setBody(&quot;super body&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void buildHp() &#123;</div><div class="line">        role.setHp(120d);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void buildSp() &#123;</div><div class="line">        role.setSp(120d);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void buildMp() &#123;</div><div class="line">        role.setMp(120d);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Role getResult() &#123;</div><div class="line">        return role;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>指挥者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Director &#123;</div><div class="line"></div><div class="line">    public void construct(Builder builder)&#123;</div><div class="line">        builder.buildBody();</div><div class="line">        builder.buildHead();</div><div class="line">        builder.buildFace();</div><div class="line">        builder.buildHp();</div><div class="line">        builder.buildMp();</div><div class="line">        builder.buildSp();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class Main &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">        Director director = new Director();</div><div class="line">        Builder commonBuilder = new CommonRoleBuilder();</div><div class="line"></div><div class="line">        director.construct(commonBuilder);</div><div class="line">        Role commonRole = commonBuilder.getResult();</div><div class="line">        System.out.println(commonRole);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里，一个建造者模式已经完成了，是不是很简单？</p>
<p>再回到之前的需求，看看我们是否都满足？</p>
<p>由于建造角色的过程比较复杂，其中还有相互依赖关系（如脸部依赖于头部），所以我们使用建造者模式将将建造复杂对象的过程和组成对象的部件解耦。这样既保证了基本属性全都一致（这里的一致指的是该包含的应该全都包含）也封装了其中的具体实现细节。<br>同时，在修改某个具体角色的时候我们只需要修改对应的具体角色就可以了，不会影响到其他角色。<br>如果需要新增角色，只要再增加一个具体建造者，并在该建造者中写好具体细节的建造部分代码就OK了。</p>
<p><strong>建造者模式的优缺点</strong></p>
<p>优点</p>
<p>建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在导演类中对整体而言可以取得比较好的稳定性。</p>
<p>在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</p>
<p>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</p>
<p>其次，建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。</p>
<p>缺点</p>
<p>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</p>
<p>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</p>
<p><strong>适用环境</strong></p>
<p>在以下情况下可以使用建造者模式：</p>
<p>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。<br>需要生成的产品对象的属性相互依赖，需要指定其生成顺序。<br>对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。<br>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</p>
<p><strong>建造者模式与工厂模式的区别</strong></p>
<p>我们可以看到，建造者模式与工厂模式是极为相似的，总体上，建造者模式仅仅只比工厂模式多了一个”指挥者”的角色。在建造者模式的类图中，假如把这个导演类看做是最终调用的客户端，那么图中剩余的部分就可以看作是一个简单的工厂模式了。</p>
<p>与工厂模式相比，建造者模式一般用来创建更为复杂的对象，因为对象的创建过程更为复杂，因此将对象的创建过程独立出来组成一个新的类——导演类。</p>
<p>也就是说，工厂模式是将对象的全部创建过程封装在工厂类中，由工厂类向客户端提供最终的产品；而建造者模式中，建造者类一般只提供产品类中各个组件的建造，而将具体建造过程交付给导演类。由导演类负责将各个组件按照特定的规则组建为产品，然后将组建好的产品交付给客户端。</p>
<p>建造者模式与工厂模式类似，适用的场景也很相似。一般来说，如果产品的建造很复杂，那么请用工厂模式；如果产品的建造更复杂，那么请用建造者模式。哈哈哈。。。</p>
<p><strong>总结</strong></p>
<p>建造者模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p>在建造者模式的结构中引入了一个指挥者类，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。</p>
<p><strong>建造者模式的实践</strong></p>
<p>假设你有一个类，其中包含大量属性。就像下面的User类一样。假设你想让这个类是不可变的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class User &#123;</div><div class="line">    private final String firstName;    //required</div><div class="line">    private final String lastName;    //required</div><div class="line">    private final int age;    //optional</div><div class="line">    private final String phone;    //optional</div><div class="line">    private final String address;    //optional</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这样的类中，有一些属性是必须的（required）而另外一些是可选的（optional）。如果你想要构造这个类的实例，你会怎么做？把所有属性都设置成final类型，然后使用构造函数初始化他们嘛？但是，如果你想让这个类的调用者可以从众多的可选参数中选择自己想要的进行设置怎么办？</p>
<p>第一个可想到的方案可能是重载多个构造函数，其中有一个只初始化必要的参数，还有一个会在初始化必要的参数同时初始化所有的可选参数，还有一些其他的构造函数介于两者之间，就是一次多初始化一个可选参数。就像下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public User(String firstName, String lastName) &#123;</div><div class="line">    this(firstName, lastName, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public User(String firstName, String lastName, int age) &#123;</div><div class="line">    this(firstName, lastName, age, &quot;&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public User(String firstName, String lastName, int age, String phone) &#123;</div><div class="line">    this(firstName, lastName, age, phone, &quot;&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public User(String firstName, String lastName, int age, String phone, String address) &#123;</div><div class="line">    this.firstName = firstName;</div><div class="line">    this.lastName = lastName;</div><div class="line">    this.age = age;</div><div class="line">    this.phone = phone;</div><div class="line">    this.address = address;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先可以肯定的是，这样做是可以满足要求的。当然，这种方式的缺点也是很明显的。当一个类中只有几个参数的时候还好，如果一旦类中的参数逐渐增大，那么这个类就会变得很难阅读和维护。更重要的是，这样的一个类，调用者会很难使用。我到底应该使用哪个构造方法？是包含两个参数的还是包含三个参数的？如果我没有传递值的话那些属性的默认值是什么？如果我只想对address赋值而不对age和phone赋值怎么办？遇到这种情况可能我只能调用那个参数最全的构造函数，然后对于我不想要的参数值传递一个默认值。此外，如果多个参数的类型都相同那就很容易让人困惑，第一个String类型的参数到底是number还是address呢？</p>
<p>还有没有其他方案可选择呢？我们可以遵循JavaBean规范，定义一个只包含无参数的构造方法和getter、setter方法的JavaBean。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class User &#123;</div><div class="line">    private String firstName; // required</div><div class="line">    private String lastName; // required</div><div class="line">    private int age; // optional</div><div class="line">    private String phone; // optional</div><div class="line">    private String address;  //optional</div><div class="line"></div><div class="line">    public String getFirstName() &#123;</div><div class="line">        return firstName;</div><div class="line">    &#125;</div><div class="line">    public void setFirstName(String firstName) &#123;</div><div class="line">        this.firstName = firstName;</div><div class="line">    &#125;</div><div class="line">    public String getLastName() &#123;</div><div class="line">        return lastName;</div><div class="line">    &#125;</div><div class="line">    public void setLastName(String lastName) &#123;</div><div class="line">        this.lastName = lastName;</div><div class="line">    &#125;</div><div class="line">    public int getAge() &#123;</div><div class="line">        return age;</div><div class="line">    &#125;</div><div class="line">    public void setAge(int age) &#123;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line">    public String getPhone() &#123;</div><div class="line">        return phone;</div><div class="line">    &#125;</div><div class="line">    public void setPhone(String phone) &#123;</div><div class="line">        this.phone = phone;</div><div class="line">    &#125;</div><div class="line">    public String getAddress() &#123;</div><div class="line">        return address;</div><div class="line">    &#125;</div><div class="line">    public void setAddress(String address) &#123;</div><div class="line">        this.address = address;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式看上去很容易阅读和维护。对于调用者来说，我只需要创建一个空的对象，然后对于我想设置的参数调用setter方法设置就好了。这难道还有什么问题吗？其实存在两个问题。第一个问题是该类的实例状态不固定。如果你想创建一个User对象，该对象的5个属性都要赋值，那么直到所有的setXX方法都被调用之前，该对象都没有一个完整的状态。这意味着在该对象状态还不完整的时候，一部分客户端程序可能看见这个对象并且以为该对象已经构造完成。这种方法的第二个不足是User类是易变的（因为没有属性是final的）。你将会失去不可变对象带来的所有优点。</p>
<p>幸运的是应对这种场景我们有第三种选择，建造者模式。解决方案类似如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">public class User &#123;</div><div class="line">    private final String firstName; // required</div><div class="line">    private final String lastName; // required</div><div class="line">    private final int age; // optional</div><div class="line">    private final String phone; // optional</div><div class="line">    private final String address; // optional</div><div class="line"></div><div class="line">    private User(UserBuilder builder) &#123;</div><div class="line">        this.firstName = builder.firstName;</div><div class="line">        this.lastName = builder.lastName;</div><div class="line">        this.age = builder.age;</div><div class="line">        this.phone = builder.phone;</div><div class="line">        this.address = builder.address;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getFirstName() &#123;</div><div class="line">        return firstName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getLastName() &#123;</div><div class="line">        return lastName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getAge() &#123;</div><div class="line">        return age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getPhone() &#123;</div><div class="line">        return phone;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getAddress() &#123;</div><div class="line">        return address;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static class UserBuilder &#123;</div><div class="line">        private final String firstName;</div><div class="line">        private final String lastName;</div><div class="line">        private int age;</div><div class="line">        private String phone;</div><div class="line">        private String address;</div><div class="line"></div><div class="line">        public UserBuilder(String firstName, String lastName) &#123;</div><div class="line">            this.firstName = firstName;</div><div class="line">            this.lastName = lastName;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public UserBuilder age(int age) &#123;</div><div class="line">            this.age = age;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public UserBuilder phone(String phone) &#123;</div><div class="line">            this.phone = phone;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public UserBuilder address(String address) &#123;</div><div class="line">            this.address = address;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public User build() &#123;</div><div class="line">            return new User(this);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>值得注意的几个要点:</p>
<p>User类的构造函数是私有的，这意味着你不能在外面直接创建这个类的对象。<br>该类是不可变的。所有属性都是final类型的，在构造方法里面被赋值。另外，我们只为它们提供了getter方法。<br>builder类使用流式接口风格，让客户端代码阅读起来更容易（我们马上就会看到一个它的例子）<br>builder的构造方法只接收必要的参数，为了确保这些属性在构造方法里赋值，只有这些属性被定义成final类型。</p>
<p>使用建造者模式有在本文开始时提到的两种方法的所有优点，并且没有它们的缺点。客户端代码写起来更简单，更重要的是，更易读。我听过的关于该模式的唯一批判是你必须在builder类里面复制类的属性。然而，考虑到这个事实，builder类通常是需要建造的类的一个静态类成员，它们一起扩展起来相当容易。</p>
<p>现在，试图创建一个新的User对象的客户端代码看起来如何那？让我们来看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public User getUser() &#123;</div><div class="line">    return new</div><div class="line">            User.UserBuilder(&quot;Jhon&quot;, &quot;Doe&quot;)</div><div class="line">            .age(30)</div><div class="line">            .phone(&quot;1234567&quot;)</div><div class="line">            .address(&quot;Fake address 1234&quot;)</div><div class="line">            .build();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果UserBuilder没有设置为static的，以上代码会有编译错误。错误提示：User is not an enclosing class</p>
<p>以上代码看上去相当整洁。我们可以只通过一行代码就可以创建一个User对象，并且这行代码也很容易读懂。除此之外，这样还能确保无论何时你想获取该类的对象都不会是不完整的：因为创建对象的过程是一气呵成的，一旦对象创建完成之后就不可修改了。</p>
<p>这种模式非常灵活，一个单独的builder类可以通过在调用build方法之前改变builder的属性来创建多个对象。builder类甚至可以在每次调用之间自动补全一些生成的字段，例如一个id或者序列号。</p>
<p>值得注意的是，像构造函数一样，builder可以对参数的合法性进行检查，一旦发现参数不合法可以抛出IllegalStateException异常。</p>
<p>但是，很重要的一点是，如果要检查参数的合法性，一定要先把参数传递给对象，然后在检查对象中的参数是否合法。其原因是因为builder并不是线程安全的。如果我们在创建真正的对象之前验证参数，参数值可能被另一个线程在参数验证完和参数被拷贝完成之间的时间修改。这段时间周期被称作“脆弱之窗”。我们的例子中情况如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public User build() &#123;</div><div class="line">    User user = new user(this);</div><div class="line">    if (user.getAge() &gt; 120) &#123;</div><div class="line">        throw new IllegalStateException(“Age out of range”); // thread-safe</div><div class="line">    &#125;</div><div class="line">    return user;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上一个代码版本是线程安全的因为我们首先创建user对象，然后在不可变对象上验证条件约束。下面的代码在功能上看起来一样但是它不是线程安全的，你应该避免这么做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public User build() &#123;</div><div class="line">    if (age &gt; 120) &#123;</div><div class="line">        throw new IllegalStateException(“Age out of range”); // bad, not thread-safe</div><div class="line">    &#125;</div><div class="line">    // This is the window of opportunity for a second thread to modify the value of age</div><div class="line">    return new User(this);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>建造者模式最后的一个优点是builder可以作为参数传递给一个方法，让该方法有为客户端创建一个或者多个对象的能力，而不需要知道创建对象的任何细节。为了这么做你可能通常需要一个如下所示的简单接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Builder &#123;</div><div class="line">    T build();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>借用之前的User例子，UserBuilder类可以实现Builder。如此，我们可以有如下的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UserCollection buildUserCollection(Builder userBuilder)&#123;...&#125;</div></pre></td></tr></table></figure>
<p>关于这这最后一个优点的部分内容并没太看懂，希望有理解的人能过不吝赐教。</p>
<p>好吧，这确实是一篇很长的文章。总而言之，建造者模式在多于几个参数（虽然不是很科学准确，但是我通常把四个参数作为使用建造者模式的一个很好的指示器），特别是当大部分参数都是可选的时候。你可以让客户端代码在阅读，写和维护方面更容易。另外，你的类可以保持不可变特性，让你的代码更安全。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;建造者模式（Builder Pattern）是一种创建型设计模式，又名：生成器模式。GOF 给建造者模式的定义为：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。这句话说的比较抽象，其实解释一下就是：&lt;strong&gt;将建造复杂对象的过程和组成对象的部件解耦。&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://manongtalk.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式小结</title>
    <link href="http://manongtalk.com/2016/09/04/2016-09-04-factory-compare/"/>
    <id>http://manongtalk.com/2016/09/04/2016-09-04-factory-compare/</id>
    <published>2016-09-05T01:53:20.000Z</published>
    <updated>2016-11-13T02:36:00.763Z</updated>
    
    <content type="html"><![CDATA[<p><strong>分类</strong></p>
<p>工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。<br><a id="more"></a><br>工厂模式可以分为三类：</p>
<p>1）简单工厂模式（Simple Factory）<br>2）工厂方法模式（Factory Method）<br>3）抽象工厂模式（Abstract Factory）</p>
<p>这三种模式从上到下逐步抽象，并且更具一般性。GOF在《设计模式》一书中将工厂模式分为两类：工厂方法模式（Factory Method）与抽象工厂模式（Abstract Factory）。将简单工厂模式（Simple Factory）看为工厂方法模式的一种特例，两者归为一类。</p>
<p><strong>创建型模式</strong></p>
<p>前面介绍过的三种工厂模式在设计模式的分类中都属于创建型模式。</p>
<p>创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。</p>
<p>创建型模式在创建什么(What)，由谁创建(Who)，何时创建(When)等方面都为软件设计者提供了尽可能大的灵活性。创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。</p>
<p><strong>工厂模式的优点</strong></p>
<p>工厂模式是创建型模式中比较重要的。<br>工厂模式的主要功能就是帮助我们实例化对象的。之所以名字中包含工厂模式四个字，是因为对象的实例化过程是通过工厂实现的，是用工厂代替new操作的。<br>这样做的好处是封装了对象的实例化细节，尤其是对于实例化较复杂或者对象的生命周期应该集中管理的情况。会给你系统带来更大的可扩展性和尽量少的修改量。</p>
<p><strong>三种工厂模式之间的演化与区别</strong></p>
<p><img src="https://raw.githubusercontent.com/kylelua/manongtalk/master/img/2016-09-04-factory-compare/factory.png" alt=""></p>
<p>简单工厂 ： 用来生产同一等级结构中的任意产品。（对于增加新的产品，主要是新增产品，就要修改工厂类。符合单一职责原则。不符合开放-封闭原则）</p>
<p>工厂方法 ：用来生产同一等级结构中的固定产品。（支持增加任意产品，新增产品时不需要更改已有的工厂，需要增加该产品对应的工厂。符合单一职责原则、符合开放-封闭原则。但是引入了复杂性）</p>
<p>抽象工厂 ：用来生产不同产品族的全部产品。（增加新产品时，需要修改工厂，增加产品族时，需要增加工厂。符合单一职责原则，部分符合开放-封闭原则，降低了复杂性）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;分类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。&lt;br&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://manongtalk.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>抽象工厂模式 (Abstract Factory Pattern)</title>
    <link href="http://manongtalk.com/2016/09/04/2016-09-04-abs-factory/"/>
    <id>http://manongtalk.com/2016/09/04/2016-09-04-abs-factory/</id>
    <published>2016-09-05T01:36:43.000Z</published>
    <updated>2016-11-13T02:23:44.823Z</updated>
    
    <content type="html"><![CDATA[<p><strong>工厂模式的简单回顾</strong></p>
<p>在介绍了简单工厂模式和工厂方法模式之后，相信很多人对工厂模式（如果单独提到工厂模式，即包括简单工厂模式、工厂方法模式及本文即将介绍的抽象工厂模式）的思想都有了一定的理解。这里我们在简单回顾一下。<br><a id="more"></a><br>工厂模式的主要功能就是帮助我们实例化对象的。之所以名字中包含工厂模式四个字，是因为对象的实例化过程是通过工厂实现的，是用工厂方法代替new操作的。</p>
<p>这样做的好处是封装了对象的实例化细节，尤其是对于实例化较复杂或者对象的生命周期应该集中管理的情况。会给你系统带来更大的可扩展性和尽量少的修改量。</p>
<p><strong>简单工厂模式的优缺点</strong></p>
<p>优点：<br>1、屏蔽产品的具体实现，调用者只关心产品的接口。<br>2、实现简单</p>
<p>缺点：<br>1、增加产品，需要修改工厂类，不符合开放-封闭原则<br>2、工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则</p>
<p><strong>工厂方法模式的优缺点</strong></p>
<p>优点：<br>1、继承了简单工厂模式的优点<br>2、符合开放-封闭原则</p>
<p>缺点：<br>1、增加产品，需要增加新的工厂类，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。</p>
<p>本文要介绍了抽象工厂模式，是在简单工厂模式和工厂方法模式的基础上衍生出的另外一种创建型设计模式。</p>
<p><strong>概念</strong></p>
<p>抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。</p>
<p>抽象工厂模式提供了一种方式，可以将同一产品族的单独的工厂封装起来。在正常使用中，客户端程序需要创建抽象工厂的具体实现，然后使用抽象工厂作为接口来创建这一主题的具体对象。客户端程序不需要知道（或关心）它从这些内部的工厂方法中获得对象的具体类型，因为客户端程序仅使用这些对象的通用接口。抽象工厂模式将一组对象的实现细节与他们的一般使用分离开来。</p>
<p><strong>产品族</strong></p>
<p>来认识下什么是产品族: 位于不同产品等级结构中,功能相关的产品组成的家族。如下面的例子，就有两个产品族：跑车族和商务车族。</p>
<p><img src="https://raw.githubusercontent.com/kylelua/manongtalk/master/img/2016-09-04-abs-factory/abstructFactory1.png" alt="产品族"></p>
<p><strong>用途</strong></p>
<p>抽象工厂模式和工厂方法模式一样，都符合开放-封闭原则。但是不同的是，工厂方法模式在增加一个具体产品的时候，都要增加对应的工厂。但是抽象工厂模式只有在新增一个类型的具体产品时才需要新增工厂。也就是说，工厂方法模式的一个工厂只能创建一个具体产品。而抽象工厂模式的一个工厂可以创建属于一类类型的多种具体产品。工厂创建产品的个数介于简单工厂模式和工厂方法模式之间。</p>
<p>在以下情况下可以使用抽象工厂模式：</p>
<p>1)一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。<br>2)系统中有多于一个的产品族，而每次只使用其中某一产品族。<br>3)属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。<br>4)系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</p>
<p><strong>实现方式</strong></p>
<p>抽象工厂模式包含如下角色：</p>
<p>AbstractFactory(抽象工厂)：用于声明生成抽象产品的方法</p>
<p>ConcreteFactory(具体工厂)：实现了抽象工厂声明的生成抽象产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中；</p>
<p>AbstractProduct(抽象产品)：为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法；</p>
<p>Product(具体产品)：定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法。</p>
<p>本文的例子采用一个汽车代工厂造汽车的例子。假设我们是一家汽车代工厂商，我们负责给奔驰和特斯拉两家公司制造车子。我们简单的把奔驰车理解为需要加油的车，特斯拉为需要充电的车。其中奔驰车中包含跑车和商务车两种，特斯拉同样也包含奔驰车和商务车。</p>
<p><img src="https://raw.githubusercontent.com/kylelua/manongtalk/master/img/2016-09-04-abs-factory/abstructFactory2.png" alt=""></p>
<p>以上场景，我们就可以把跑车和商务车分别对待，对于跑车有单独的工厂创建，商务车也有单独的工厂。这样，以后无论是再帮任何其他厂商造车，只要是跑车或者商务车我们都不需要再引入工厂。同样，如果我们要增加一种其他类型的车，比如越野车，我们也不需要对跑车或者商务车的任何东西做修改。</p>
<p>下面是抽象产品，奔驰车和特斯拉车：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public interface BenzCar &#123;</div><div class="line"></div><div class="line">    //加汽油</div><div class="line">    public void gasUp();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public interface TeslaCar &#123;</div><div class="line"></div><div class="line">    //充电</div><div class="line">    public void charge();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是具体产品，奔驰跑车、奔驰商务车、特斯拉跑车、特斯拉商务车：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class BenzSportCar implements BenzCar &#123;</div><div class="line">    public void gasUp() &#123;</div><div class="line">        System.out.println(&quot;给我的奔驰跑车加最好的汽油&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class BenzBusinessCar implements BenzCar&#123;</div><div class="line">    public void gasUp() &#123;</div><div class="line">        System.out.println(&quot;给我的奔驰商务车加一般的汽油&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class TeslaSportCar implements TeslaCar &#123;</div><div class="line">    public void charge() &#123;</div><div class="line">        System.out.println(&quot;给我特斯拉跑车冲满电&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class TeslaBusinessCar implements TeslaCar &#123;</div><div class="line">    public void charge() &#123;</div><div class="line">        System.out.println(&quot;给我特斯拉商务车冲满电&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是抽象工厂：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface CarFactory &#123;</div><div class="line"></div><div class="line">    public BenzCar getBenzCar();</div><div class="line">    public TeslaCar getTeslaCar();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是具体工厂：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class SportCarFactory implements CarFactory &#123;</div><div class="line">    public BenzCar getBenzCar() &#123;</div><div class="line">        return new BenzSportCar();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TeslaCar getTeslaCar() &#123;</div><div class="line">        return new TeslaSportCar();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class BusinessCarFactory implements CarFactory &#123;</div><div class="line">    public BenzCar getBenzCar() &#123;</div><div class="line">        return new BenzBusinessCar();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TeslaCar getTeslaCar() &#123;</div><div class="line">        return new TeslaBusinessCar();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>“开闭原则”的倾斜性</strong></p>
<p>“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的。对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：</p>
<p>增加产品族：对于增加新的产品族，工厂方法模式很好的支持了“开闭原则”，对于新增加的产品族，只需要对应增加一个新的具体工厂即可，对已有代码无须做任何修改。</p>
<p>增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，不能很好地支持“开闭原则”。</p>
<p>抽象工厂模式的这种性质称为“开闭原则”的倾斜性，抽象工厂模式以一种倾斜的方式支持增加新的产品，它为新产品族的增加提供方便，但不能为新的产品等级结构的增加提供这样的方便。</p>
<p><strong>三种工厂模式之间的关系</strong></p>
<p>当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；</p>
<p>抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构。</p>
<p>当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。</p>
<p><strong>总结</strong></p>
<p>抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。</p>
<p>抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。</p>
<p>抽象工厂模式的主要优点是隔离了具体类的生成，使得客户并不需要知道什么被创建，而且每次可以通过具体工厂类创建一个产品族中的多个对象，增加或者替换产品族比较方便，增加新的具体工厂和产品族很方便；主要缺点在于增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;工厂模式的简单回顾&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在介绍了简单工厂模式和工厂方法模式之后，相信很多人对工厂模式（如果单独提到工厂模式，即包括简单工厂模式、工厂方法模式及本文即将介绍的抽象工厂模式）的思想都有了一定的理解。这里我们在简单回顾一下。&lt;br&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://manongtalk.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>工厂方法模式 (Factory Method Pattern)</title>
    <link href="http://manongtalk.com/2016/09/04/2016-09-04-factory-method/"/>
    <id>http://manongtalk.com/2016/09/04/2016-09-04-factory-method/</id>
    <published>2016-09-05T00:58:05.000Z</published>
    <updated>2016-11-13T02:36:46.667Z</updated>
    
    <content type="html"><![CDATA[<p><strong>概念</strong></p>
<p>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。工厂方法模式是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。”<br><a id="more"></a><br><strong>用途</strong></p>
<p>工厂方法模式和简单工厂模式虽然都是通过工厂来创建对象，他们之间最大的不同是——工厂方法模式在设计上完全完全符合“开闭原则”。</p>
<p>在以下情况下可以使用工厂方法模式：</p>
<p>1.一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。</p>
<p>2.一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</p>
<p>3.将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</p>
<p><strong>实现方式</strong></p>
<p>工厂方法模式包含如下角色：</p>
<p>Product：抽象产品（Operation）</p>
<p>ConcreteProduct：具体产品(OperationAdd)</p>
<p>Factory：抽象工厂(IFactory)</p>
<p>ConcreteFactory：具体工厂(AddFactory)</p>
<p><img src="https://raw.githubusercontent.com/kylelua/manongtalk/master/img/2016-09-04-factory-method/factoryMethod.png" alt=""></p>
<p>这里还用计算器的例子。在保持Operation，OperationAdd，OperationDiv，OperationSub，OperationMul等几个方法不变的情况下，修改简单工厂模式中的工厂类（OperationFactory）。替代原有的那个”万能”的大工厂类，这里使用工厂方法来代替：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">//工厂接口</div><div class="line">public interface IFactory &#123;</div><div class="line">    Operation CreateOption();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//加法类工厂</div><div class="line">public class AddFactory implements IFactory &#123;</div><div class="line"></div><div class="line">    public Operation CreateOption() &#123;</div><div class="line">        return new OperationAdd();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//除法类工厂</div><div class="line">public class DivFactory implements IFactory &#123;</div><div class="line"></div><div class="line">    public Operation CreateOption() &#123;</div><div class="line">        return new OperationDiv();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//乘法类工厂</div><div class="line">public class MulFactory implements IFactory &#123;</div><div class="line"></div><div class="line">    public Operation CreateOption() &#123;</div><div class="line">        return new OperationMul();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//减法类工厂</div><div class="line">public class SubFactory implements IFactory &#123;</div><div class="line"></div><div class="line">    public Operation CreateOption() &#123;</div><div class="line">        return new OperationSub();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，在客户端中想要执行加法运算时，需要以下方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Main &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        IFactory factory = new AddFactory();</div><div class="line">        Operation operationAdd =  factory.CreateOption();</div><div class="line">        operationAdd.setValue1(10);</div><div class="line">        operationAdd.setValue2(5);</div><div class="line">        System.out.println(operationAdd.getResult());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里，一个工厂方法模式就已经写好了。</p>
<p>从代码量上看，这种工厂方法模式比简单工厂方法模式更加复杂。针对不同的操作（Operation）类都有对应的工厂。很多人会有以下疑问：</p>
<p><strong>貌似工厂方法模式比简单工厂模式要复杂的多？<br>工厂方法模式和我自己创建对象没什么区别？为什么要多搞出一些工厂来？</strong></p>
<p>下面就针对以上两个问题来深入理解一下工厂方法模式。</p>
<p><strong>工厂方法模式的利与弊</strong></p>
<p><strong>为什么要使用工厂来创建对象？</strong></p>
<p>封装对象的创建过程</p>
<p>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</p>
<p>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</p>
<p><strong>为什么每种对象要单独有一个工厂？</strong></p>
<p>符合”开放-封闭原则”</p>
<p>主要目的是为了解耦。在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</p>
<p><strong>以上就是工厂方法模式的优点。但是，工厂模式也有一些不尽如人意的地方：</strong></p>
<p>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</p>
<p>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</p>
<p><strong>工厂方法与简单工厂的区别</strong></p>
<p>工厂模式克服了简单工厂模式违背开放-封闭原则的缺点，又保持了封装对象创建过程的优点。<br>他们都是集中封装了对象的创建，使得要更换对象时，不需要做大的改动就可实现，降低了客户端与产品对象的耦合。</p>
<p><strong>总结</strong></p>
<p>工厂方法模式是简单工厂模式的进一步抽象和推广。</p>
<p>由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。</p>
<p>在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。</p>
<p>工厂方法模式的主要优点是增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性；其缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。工厂方法模式是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。”&lt;br&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://manongtalk.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>简单工厂 (Simple Factory)</title>
    <link href="http://manongtalk.com/2016/09/04/2016-09-04-simple-factory/"/>
    <id>http://manongtalk.com/2016/09/04/2016-09-04-simple-factory/</id>
    <published>2016-09-05T00:28:54.000Z</published>
    <updated>2016-11-13T02:37:26.799Z</updated>
    
    <content type="html"><![CDATA[<p><strong>概念</strong></p>
<p>简单工厂模式是属于创建型模式，又叫做静态工厂方法（Static Factory Method）模式。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。<br>值得注意的是，简单工厂模式并不属于23种GOF设计模式之一。但是他是抽象工厂模式，工厂方法模式的基础，并且也有广泛的应用。</p>
<a id="more"></a>
<p><strong>用途</strong></p>
<p>在介绍简单工厂模式之前，我们尝试解决以下问题：<br>现在我们要使用面向对象的形式定义计算器，为了实现各算法之间的解耦。主要的用到的类如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">// 计算类的基类</div><div class="line">public abstract class Operation &#123;</div><div class="line"></div><div class="line">    private double value1 = 0;</div><div class="line">    private double value2 = 0;</div><div class="line"></div><div class="line">    public double getValue1() &#123;</div><div class="line">        return value1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setValue1(double value1) &#123;</div><div class="line">        this.value1 = value1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public double getValue2() &#123;</div><div class="line">        return value2;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setValue2(double value2) &#123;</div><div class="line">        this.value2 = value2;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected abstract double getResule();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//加法</div><div class="line">public class OperationAdd extends Operation &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected double getResule() &#123;</div><div class="line">        return getValue1() + getValue2();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//减法</div><div class="line">public class OperationSub extends Operation &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected double getResule() &#123;</div><div class="line">        return getValue1() - getValue2();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//乘法</div><div class="line">public class OperationMul extends Operation &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected double getResule() &#123;</div><div class="line">        return getValue1() * getValue2();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//除法</div><div class="line">public class OperationDiv extends Operation &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected double getResule() &#123;</div><div class="line">        if (getValue2() != 0) &#123;</div><div class="line">            return getValue1() / getValue2();</div><div class="line">        &#125;</div><div class="line">        throw new IllegalArgumentException(&quot;除数不能为零&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我想要执行加法运算时，可以使用如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Main &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        OperationAdd operationAdd = new OperationAdd();</div><div class="line">        operationAdd.setValue1(10);</div><div class="line">        operationAdd.setValue2(5);</div><div class="line">        System.out.println(operationAdd.getResule());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我需要执行减法运算时，我就要创建一个OperationSub类。也就是说，我想要使用不同的运算的时候就要创建不同的类，并且要明确知道该类的名字。那么这种重复的创建类的工作其实可以放到一个统一的工厂类中。</p>
<p>简单工厂模式有以下优点：</p>
<p>1、一个调用者想创建一个对象，只要知道其名称就可以了。</p>
<p>2、屏蔽产品的具体实现，调用者只关心产品的接口。</p>
<p><strong>实现方式</strong></p>
<p>简单工厂模式其实和他的名字一样，很简单。先来看看它的组成:</p>
<p>1)工厂类角色:这是本模式的核心,含有一定的商业逻辑和判断逻辑。在java中它往往由一个具体类实现。（OperationFactory）</p>
<p>2)抽象产品角色:它一般是具体产品继承的父类或者实现的接口。在java中由接口或者抽象类来实现。（Operation）</p>
<p>3)具体产品角色:工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现。来用类图来清晰的表示下的它们之间的关系（OperationAdd\OperationSub等）</p>
<p><img src="https://raw.githubusercontent.com/kylelua/manongtalk/master/img/2016-09-04-simple-factory/simpleFactory.png" alt=""></p>
<p>在原有类的基础上，定义工厂类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">//工厂类</div><div class="line">public class OperationFactory &#123;</div><div class="line"></div><div class="line">    public static Operation createOperation(String operation) &#123;</div><div class="line">        Operation oper = null;</div><div class="line">        switch (operation) &#123;</div><div class="line"></div><div class="line">            case &quot;+&quot;:</div><div class="line">                oper = new OperationAdd();</div><div class="line">                break;</div><div class="line"></div><div class="line">            case &quot;-&quot;:</div><div class="line">                oper = new OperationSub();</div><div class="line">                break;</div><div class="line"></div><div class="line">            case &quot;*&quot;:</div><div class="line">                oper = new OperationMul();</div><div class="line">                break;</div><div class="line"></div><div class="line">            case &quot;/&quot;:</div><div class="line">                oper = new OperationDiv();</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                throw new UnsupportedOperationException(&quot;不支持该操作&quot;);</div><div class="line">        &#125;</div><div class="line">        return oper;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有了工厂类之后，可以使用工厂创建对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Operation operationAdd = OperationFactory.createOperation(&quot;+&quot;);</div><div class="line">operationAdd.setValue1(10);</div><div class="line">operationAdd.setValue2(5);</div><div class="line">System.out.println(operationAdd.getResule());</div></pre></td></tr></table></figure>
<p>通过简单工厂模式，该计算器的使用者不需要关系实现加法逻辑的那个类的具体名字，他只要知道该类对应的参数”+”就可以了。</p>
<p><strong>简单工厂模式存在的问题</strong></p>
<p>在《设计模式概述》中介绍了设计模式一般应该遵循的几个原则。</p>
<p>下面我们从开闭原则(对扩展开放;对修改封闭)上来分析下简单工厂模式。当我们需要增加一种计算时，例如开平方。这个时候我们需要先定义一个类继承Operation类，其中实现平方的代码。除此之外我们还要修改OperationFactory类的代码，增加一个case。这显然是违背开闭原则的。可想而知对于新产品的加入，工厂类是很被动的。</p>
<p>我们举的例子是最简单的情况。而在实际应用中，很可能产品是一个多层次的树状结构。简单工厂可能就不太适用了。</p>
<p><strong>总结</strong></p>
<p>工厂类是整个简单工厂模式的关键。包含了必要的逻辑判断，根据外界给定的信息，决定究竟应该创建哪个具体类的对象。通过使用工厂类，外界可以从直接创建具体产品对象的尴尬局面摆脱出来，仅仅需要负责“消费”对象就可以了。而不必管这些对象究竟如何创建及如何组织的。明确了各自的职责和权利，有利于整个软件体系结构的优化。</p>
<p>但是</p>
<p>由于工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则，将全部创建逻辑集中到了一个工厂类中；它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。</p>
<p>当系统中的具体产品类不断增多时候，可能会出现要求工厂类根据不同条件创建不同实例的需求．这种对条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系统的维护和扩展非常不利；</p>
<p>这些缺点在工厂方法模式中得到了一定的解决。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单工厂模式是属于创建型模式，又叫做静态工厂方法（Static Factory Method）模式。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。&lt;br&gt;值得注意的是，简单工厂模式并不属于23种GOF设计模式之一。但是他是抽象工厂模式，工厂方法模式的基础，并且也有广泛的应用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://manongtalk.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>单例模式（Singleton Pattern）</title>
    <link href="http://manongtalk.com/2016/09/04/2016-09-04-design-pattern-singleton/"/>
    <id>http://manongtalk.com/2016/09/04/2016-09-04-design-pattern-singleton/</id>
    <published>2016-09-04T20:25:20.000Z</published>
    <updated>2016-11-13T02:35:27.379Z</updated>
    
    <content type="html"><![CDATA[<p><strong>概念</strong><br>单例模式（Singleton Pattern）是最简单的设计模式之一。这种类型的设计模式属于创建型模式。在 GOF 书中给出的定义为：保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br><a id="more"></a><br>单例模式一般体现在类声明中，单例的类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p><strong>用途</strong><br>单例模式有以下两个优点：</p>
<p>1.在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如网站首页页面缓存）。<br>2.避免对资源的多重占用（比如写文件操作）。</p>
<p>有时候，我们在选择使用单例模式的时候，不仅仅考虑到其带来的优点，还有可能是有些场景就必须要单例。比如类似”一个党只能有一个主席”的情况。</p>
<p><strong>实现方式</strong><br>我们知道，一个类的对象的产生是由类构造函数来完成的。如果一个类对外提供了public的构造方法，那么外界就可以任意创建该类的对象。所以，如果想限制对象的产生，一个办法就是将构造函数变为私有的(至少是受保护的)，使外面的类不能通过引用来产生对象。同时为了保证类的可用性，就必须提供一个自己的对象以及访问这个对象的静态方法。</p>
<p><img src="https://raw.githubusercontent.com/kylelua/manongtalk/master/img/2016-09-04-design-pattern-singleton/singleton_1.png" alt=""></p>
<p><strong>饿汉式</strong><br>下面是一个简单的单例的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//Singleton example : 饿汉式</div><div class="line">public class Singleton &#123;</div><div class="line">    //在类内部实例化一个实例</div><div class="line">    private static Singleton instance = new Singleton();</div><div class="line">    //私有的构造函数,外部无法访问</div><div class="line">    private Singleton() &#123;</div><div class="line">    &#125;</div><div class="line">    //对外提供获取实例的静态方法</div><div class="line">    public static Singleton getInstance() &#123;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这就是一个简单的单例的实现，这种实现方式我们称之为饿汉式。所谓饿汉。这是个比较形象的比喻。对于一个饿汉来说，他希望他想要用到这个实例的时候就能够立即拿到，而不需要任何等待时间。所以，通过static的静态初始化方式，在该类第一次被加载的时候，就有一个Singleton的实例被创建出来了。这样就保证在第一次想要使用该对象时，他已经被初始化好了。</p>
<p>饿汉式单例，在类被加载的时候对象就会实例化。这也许会造成不必要的消耗，因为有可能这个实例根本就不会被用到。而且，如果这个类被多次加载的话也会造成多次实例化。其实解决这个问题的方式有很多，下面提供两种解决方式，第一种是使用静态内部类的形式。第二种是使用懒汉式。</p>
<p><strong>懒汉式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//Singleton example : 懒汉式</div><div class="line">public class Singleton &#123;</div><div class="line">    //定义实例</div><div class="line">    private static Singleton instance;</div><div class="line">    //私有构造方法</div><div class="line">    private Singleton()&#123;&#125;</div><div class="line">    //对外提供获取实例的静态方法</div><div class="line">    public static Singleton getInstance() &#123;</div><div class="line">        //在对象被使用的时候才实例化</div><div class="line">        if (instance == null) &#123;</div><div class="line">            instance = new Singleton();</div><div class="line">        &#125;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面这种单例叫做懒汉式单例。懒汉，就是不会提前把实例创建出来，将类对自己的实例化延迟到第一次被引用的时候。getInstance方法的作用是希望该对象在第一次被使用的时候被new出来。</p>
<p>有没有发现，其实这种懒汉式单例其实还存在一个问题，那就是线程安全问题。在多线程情况下，有可能两个线程同时进入if语句中，这样，在两个线程都从if中退出的时候就创建了两个不一样的对象。</p>
<p>针对线程不安全的懒汉式的单例，其实解决方式很简单，就是给创建对象的步骤加锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class SynchronizedSingleton &#123;</div><div class="line">    //定义实例</div><div class="line">    private static SynchronizedSingleton instance;</div><div class="line">    //私有构造方法</div><div class="line">    private SynchronizedSingleton()&#123;&#125;</div><div class="line">    //对外提供获取实例的静态方法,对该方法加锁</div><div class="line">    public static synchronized SynchronizedSingleton getInstance() &#123;</div><div class="line">        //在对象被使用的时候才实例化</div><div class="line">        if (instance == null) &#123;</div><div class="line">            instance = new SynchronizedSingleton();</div><div class="line">        &#125;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>枚举式</strong><br>在Java 1.5之前，实现单例一般只有以上几种办法，在Java 1.5之后，还有另外一种实现单例的方式，那就是使用枚举：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public enum  Singleton &#123;</div><div class="line"></div><div class="line">    INSTANCE;</div><div class="line">    Singleton() &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象可谓是很坚强的壁垒啊，在深度分析Java的枚举类型—-枚举的线程安全性及序列化问题中有详细介绍枚举的线程安全问题和序列化问题，不过，个人认为由于1.5中才加入enum特性，用这种方式写不免让人感觉生疏，在实际工作中，我也很少看见有人这么写过，但是不代表他不好。</p>
<p><strong>总结</strong><br>本文中介绍了几种实现单例的方法，主要包括饿汉、懒汉、并发校验锁、枚举等。</p>
<p>从单例的实现中，我们可以发现，一个简单的单例模式就能涉及到这么多知识。单例模式其实如果再深入讨论，还可以涉及到序列化和多线程下的同步锁。</p>
<p>但是，在平时工作中，单例是需要慎用的。因为它造出的静态实例存在内存在不会轻易被释放。如果这个单例比较大就会吃掉很多内存资源，甚至引起崩溃。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;概念&lt;/strong&gt;&lt;br&gt;单例模式（Singleton Pattern）是最简单的设计模式之一。这种类型的设计模式属于创建型模式。在 GOF 书中给出的定义为：保证一个类仅有一个实例，并提供一个访问它的全局访问点。&lt;br&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://manongtalk.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式概述</title>
    <link href="http://manongtalk.com/2016/09/04/2016-09-04-design-pattern-overview/"/>
    <id>http://manongtalk.com/2016/09/04/2016-09-04-design-pattern-overview/</id>
    <published>2016-09-04T14:49:34.000Z</published>
    <updated>2016-11-13T02:34:45.147Z</updated>
    
    <content type="html"><![CDATA[<p>在软件工程中，设计模式（design pattern）是对软件设计中普遍存在的各种问题，所提出的解决方案。设计模式并不是固定的一套代码，而是针对某一特定问题的具体解决思路与方案。可以认为是一种最佳实践，因为他是无数软件开发人员经过长时间的实践总结出来的。<br>提到设计模式不得不提《设计模式：可复用面向对象软件的基础》（Design Patterns – Elements of Reusable Object-Oriented Software） 一书。这本书由著名的四人帮——GoF(Gang of Four)编写，其中总结了23种设计模式，并将他们分成几个大类。<br><a id="more"></a><br><strong>设计模式的六大原则</strong></p>
<p><strong>1、开闭原则（Open Close Principle）</strong></p>
<p>开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p>
<p><strong>2、里氏代换原则（Liskov Substitution Principle）</strong></p>
<p>里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
<p><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong><br>这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。</p>
<p><strong>4、接口隔离原则（Interface Segregation Principle）</strong><br>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</p>
<p><strong>5、迪米特法则（最少知道原则）（Demeter Principle）</strong><br>为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<p><strong>6、合成复用原则（Composite Reuse Principle）</strong><br>合成复用原则是尽量使用合成/聚合的方式，而不是使用继承。<br>其中前四种也是面向对象的四个基本原则。</p>
<p><strong>设计模式分类</strong></p>
<p>设计模式分为三种类型，共23种。<br><strong>创建型模式：</strong>单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。<br><strong>结构型模式：</strong>适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。<br><strong>行为型模式：</strong>模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式(责任链模式)、访问者模式。</p>
<p><strong>23种设计模式简单介绍</strong></p>
<p>按字典序排列简介如下。<br><strong>Abstract Factory（抽象工厂模式）：</strong>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br><strong>Adapter（适配器模式）：</strong>将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br><strong>Bridge（桥接模式）：</strong>将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br><strong>Builder（建造者模式）：</strong>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。<br><strong>Chain of Responsibility（责任链模式）：</strong>为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。<br><strong>Command（命令模式）：</strong>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。<br><strong>Composite（组合模式）：</strong>将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。<br><strong>Decorator（装饰模式）：</strong>动态地给一个对象添加一些额外的职责。就扩展功能而言， 它比生成子类方式更为灵活。<br><strong>Facade（外观模式）：</strong>为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br><strong>Factory Method（工厂模式）：</strong>定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method使一个类的实例化延迟到其子类。<br><strong>Flyweight（享元模式）：</strong>运用共享技术有效地支持大量细粒度的对象。<br><strong>Interpreter（解析器模式）：</strong>给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。<br><strong>Iterator（迭代器模式）：</strong>提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。<br><strong>Mediator（中介模式）：</strong>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。<br><strong>Memento（备忘录模式）：</strong>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。<br><strong>Observer（观察者模式）：</strong>定义对象间的一种一对多的依赖关系,以便当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新。<br><strong>Prototype（原型模式）：</strong>用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。<br><strong>Proxy（代理模式）：</strong>为其他对象提供一个代理以控制对这个对象的访问。<br><strong>Singleton（单例模式）：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。 单例模式是最简单的设计模式之一，但是对于Java的开发者来说，它却有很多缺陷。<br><strong>State（状态模式）：</strong>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。<br><strong>Strategy（策略模式）：</strong>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。<br><strong>Template Method（模板方法模式）：</strong>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<br><strong>Visitor（访问者模式）：</strong>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
<p><strong>23种设计模式之间的关系</strong></p>
<p><img src="https://raw.githubusercontent.com/kylelua/manongtalk/master/img/2016-09-04-design-pattern-overview/design-pattern.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在软件工程中，设计模式（design pattern）是对软件设计中普遍存在的各种问题，所提出的解决方案。设计模式并不是固定的一套代码，而是针对某一特定问题的具体解决思路与方案。可以认为是一种最佳实践，因为他是无数软件开发人员经过长时间的实践总结出来的。&lt;br&gt;提到设计模式不得不提《设计模式：可复用面向对象软件的基础》（Design Patterns – Elements of Reusable Object-Oriented Software） 一书。这本书由著名的四人帮——GoF(Gang of Four)编写，其中总结了23种设计模式，并将他们分成几个大类。&lt;br&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://manongtalk.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>也谈两句fenng的事</title>
    <link href="http://manongtalk.com/2016/08/31/2016-8-31-fenng/"/>
    <id>http://manongtalk.com/2016/08/31/2016-8-31-fenng/</id>
    <published>2016-08-31T12:55:29.000Z</published>
    <updated>2016-11-05T20:47:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近圈里一个热门话题是一个丁香园的员工深扒fenng作为CTO如何失职。fenng对此也做了专门回应。看完双方的原帖后。有一点事情貌似两个人都没有异议：<br><a id="more"></a><br>那就是fenng不具备写代码的能力。</p>
<p>OK，我以为事情到这里已经很明了了，没想到竟然引发无数网友对于CTO到底要不要会写代码的激烈讨论。甚至有一帮人理直气壮大有一番“当CTO就是不会写怎么滴”的架势。</p>
<p>我们先从体育说起，比如足球、篮球、排球等等运动，教练员一般分为两派：运动员转型或者学院出身。但不管什么派别，作为一个运动参与者，没有一定程度的训练经历是不可能非常深刻地理解一项运动的，所谓的“一定程度”，可以理解为自己参与过专业教练的训练，而且长期对训练和比赛过程有一手观察和记录，最好有专业师傅带着。而这里，所谓的“非运动员出身”，只不过是没有打过TA将要执教的专业级别的比赛而已，并不是完全没有参与过这项运动。虽然他身体的硬件条件和运动天赋不够成为优秀的运动员。但是如果有足够的悟性还是可以成为一名好教练。</p>
<p>同理，要能成为一名优秀的技术领导者，没有一定程度的实践经验是不行的。写代码用的是脑袋和手指，只要这几个器官功能还正常，花时间精力去研究技术，都能写好代码。当上技术领导者以后，可以不参与编程的具体工作，但是还是要有足够的技术直觉，即敏锐察觉出技术的薄弱环节，知道哪些事情的轻重缓急，知道技术应该往哪个方向发展。这些能力，没有几年的实践经验做累积是根本不能具备的。在这个写代码出身的CEO一抓一大把的年代，还在讨论CTO是不是要会写代码，真是可笑。</p>
<p>fenng的文笔很不错，也给丁香园做了很好的宣传，但是在我看来，他作为CTO就是水货，</p>
<p>这让我想起了亲身经历过的另一个水货CTO。美国最顶级名校，几百篇论文发表，各种大公司头衔，你到youtube上一搜可以搜出长串他的演讲。当初公司没经验，重金把他招来做CTO。来了慢慢发现,大事不妙，这货真是技术小白，用一个新词形容最为恰当“首席产品体验师”＋“首席邮件挑错师”.他把公司有限的人力资源浪费在无休止的折腾上，几个月来公司技术层面几乎止步不前。幸好，CEO是个明眼人，当机立断把他炒了。从这件事学的几点教训：</p>
<ol>
<li>CTO是可选项，并非一个公司的标配。</li>
<li>即使背景看起来很牛逼也并不一定是真牛逼</li>
<li>会写代码的能力是对CTO的起码要求。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近圈里一个热门话题是一个丁香园的员工深扒fenng作为CTO如何失职。fenng对此也做了专门回应。看完双方的原帖后。有一点事情貌似两个人都没有异议：&lt;br&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="http://manongtalk.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
</feed>

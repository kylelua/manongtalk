<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 深度学习入门(1)：感知器 | 码农说</title><meta name="description" content="深度学习入门(1)：感知器 - 卤蛋侠"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/icon0.png"><link rel="stylesheet" href="/css/casual.css"><link rel="stylesheet" href="/css/semantic.min.css"><link rel="search" type="application/opensearchdescription+xml" href="http://manongtalk.com/atom.xml" title="码农说"></head><body><div class="sidebar"><div class="ui vertical inverted menu"><div class="h100"></div><h3 class="ui inverted aligned icon header"><div class="content"><a href="/" class="title-link">码农说</a></div></h3><div class="h50"></div><div class="side-nav"><a href="/" target="_self" class="item">HOME<i class="icon home"></i></a><a href="/archives" target="_self" class="item">ARCHIVE<i class="icon archive"></i></a><a href="/tags" target="_self" class="item">TAGS<i class="icon tags"></i></a><a href="/about" target="_self" class="item">INFO<i class="icon info"></i></a></div><div class="item"><div class="ui inverted transparent icon input"><input type="text" placeholder="Search..." class="st-default-search-input"><i class="search icon"></i></div></div><div class="h50"></div></div><div class="h50 mq"><a class="ui teal big label"><i class="content icon"></i></a></div><div class="author-info"><a href="/" class="img-link"><img src="/icon1.png" class="author-photo ui tiny circular image"></a><h4 class="ui aligned icon header"><div class="content">卤蛋侠</div></h4><p class="author-desc">一个程序员的日常 | iOS & Android | Computer Vision | Artificial Intelligence</p><div class="social-outer"><div class="social-inner"><a href="https://raw.githubusercontent.com/kylelua/manongtalk/master/qrcode.jpg" target="_blank" class="social-link"><i class="icon wechat"></i></a></div></div></div></div><div class="main"><div class="wrap"><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">深度学习入门(1)：感知器</h1><div class="post-info"><div class="post-date"><h6 class="ui header"><i class="calendar icon"></i><div class="content">Dec 1, 2016</div></h6></div></div><div class="post-content"><p><strong>深度学习是啥</strong></p>
<p>在人工智能领域，有一个方法叫机器学习。在机器学习这个方法里，有一类算法叫神经网络。神经网络如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/kylelua/manongtalk/master/img/2016-12-01-deep-learning/img1.png" alt=""></p>
<p>上图中每个圆圈都是一个神经元，每条线表示神经元之间的连接。我们可以看到，上面的神经元被分成了多层，层与层之间的神经元有连接，而层内之间的神经元没有连接。最左边的层叫做输入层，这层负责接收输入数据；最右边的层叫输出层，我们可以从这层获取神经网络输出数据。输入层和输出层之间的层叫做隐藏层。</p>
<p>隐藏层比较多（大于2）的神经网络叫做深度神经网络。而深度学习，就是使用深层架构（比如，深度神经网络）的机器学习方法。</p>
<p>那么深层网络和浅层网络相比有什么优势呢？简单来说深层网络能够表达力更强。事实上，一个仅有一个隐藏层的神经网络就能拟合任何一个函数，但是它需要很多很多的神经元。而深层网络用少得多的神经元就能拟合同样的函数。也就是为了拟合一个函数，要么使用一个浅而宽的网络，要么使用一个深而窄的网络。而后者往往更节约资源。</p>
<p>深层网络也有劣势，就是它不太容易训练。简单的说，你需要大量的数据，很多的技巧才能训练好一个深层网络。这是个手艺活。</p>
<p><strong>感知器</strong></p>
<p>看到这里，如果你还是一头雾水，那也是很正常的。为了理解神经网络，我们应该先理解神经网络的组成单元——神经元。神经元也叫做感知器。感知器算法在上个世纪50-70年代很流行，也成功解决了很多问题。并且，感知器算法也是非常简单的。</p>
<p><strong>感知器的定义</strong></p>
<p>下图是一个感知器：</p>
<p><img src="https://raw.githubusercontent.com/kylelua/manongtalk/master/img/2016-12-01-deep-learning/img2.png" alt=""></p>
<p>可以看到，一个感知器有如下组成部分：</p>
<p>1) <em>输入权值</em> 一个感知器可以接收多个输入(x1, x2, … , xn)，每个输入上有一个权值(w0, w1, …, wn)，此外还有一个偏置项b，就是上图中的w0。</p>
<p>2) <em>激活函数</em> 感知器的激活函数可以有很多选择，比如我们可以选择下面这个阶跃函数来作为激活函数：</p>
<p><img src="https://raw.githubusercontent.com/kylelua/manongtalk/master/img/2016-12-01-deep-learning/img3.png" alt=""></p>
<p>3) <em>输出</em> 感知器的输出由下面这个公式来计算</p>
<p><img src="https://raw.githubusercontent.com/kylelua/manongtalk/master/img/2016-12-01-deep-learning/img4.png" alt=""></p>
<p>接下来我们用一个简单的例子来帮助理解。</p>
<p><em>例子：用感知器实现and函数</em></p>
<p>我们设计一个感知器，让它来实现and运算。程序员都知道，and是一个二元函数（带有两个参数和），下面是它的真值表：</p>
<p><img src="https://raw.githubusercontent.com/kylelua/manongtalk/master/img/2016-12-01-deep-learning/img5.png" alt=""></p>
<p>为了计算方便，我们用0表示false，用1表示true。这没什么难理解的，对于C语言程序员来说，这是天经地义的。</p>
<p>我们令<br><img src="https://raw.githubusercontent.com/kylelua/manongtalk/master/img/2016-12-01-deep-learning/img6.png" alt=""><br>而激活函数就是前面写出来的阶跃函数，这时，感知器就相当于and函数。不明白？我们验算一下：</p>
<p>输入上面真值表的第一行，即，那么根据公式(1)，计算输出：<br><img src="https://raw.githubusercontent.com/kylelua/manongtalk/master/img/2016-12-01-deep-learning/img7.png" alt=""></p>
<p>也就是当都为0的时候，为0，这就是真值表的第一行。读者可以自行验证上述真值表的第二、三、四行。</p>
<p><strong>感知器还能做什么</strong></p>
<p>事实上，感知器不仅仅能实现简单的布尔运算。它可以拟合任何的线性函数，任何线性分类或线性回归问题都可以用感知器来解决。前面的布尔运算可以看作是二分类问题，即给定一个输入，输出0（属于分类0）或1（属于分类1）。如下面所示，and运算是一个线性分类问题，即可以用一条直线把分类0（false，红叉表示）和分类1（true，绿点表示）分开。</p>
<p><img src="https://raw.githubusercontent.com/kylelua/manongtalk/master/img/2016-12-01-deep-learning/img8.png" alt=""></p>
<p>然而，感知器却不能实现异或运算，如下图所示，异或运算不是线性的，你无法用一条直线把分类0和分类1分开。</p>
<p><img src="https://raw.githubusercontent.com/kylelua/manongtalk/master/img/2016-12-01-deep-learning/img9.png" alt=""></p>
<p><strong>感知器的训练</strong></p>
<p>现在，你可能困惑前面的权重项和偏置项的值是如何获得的呢？这就要用到感知器训练算法：将权重项和偏置项初始化为0，然后，利用下面的感知器规则迭代的修改和，直到训练完成。<br><img src="https://raw.githubusercontent.com/kylelua/manongtalk/master/img/2016-12-01-deep-learning/img10.png" alt=""></p>
<p>其中:<br><img src="https://raw.githubusercontent.com/kylelua/manongtalk/master/img/2016-12-01-deep-learning/img11.png" alt=""></p>
<p>w是与输入对应的权重项，b是偏置项。t是训练样本的实际值，一般称之为label。而是感知器的输出值，它是根据公式(1)计算得出。是一个称为学习速率的常数，其作用是控制每一步调整权的幅度。</p>
<p>每次从训练数据中取出一个样本的输入向量x，使用感知器计算其输出y，再根据上面的规则来调整权重。每处理一个样本就调整一次权重。经过多轮迭代后（即全部的训练数据被反复处理多轮），就可以训练出感知器的权重，使之实现目标函数。</p>
<p><strong>编程实战：实现感知器</strong></p>
<p>对于程序员来说，没有什么比亲自动手实现学得更快了，而且，很多时候一行代码抵得上千言万语。接下来我们就将实现一个感知器。</p>
<p>下面是一些说明：</p>
<p>1) 使用python语言。python在机器学习领域用的很广泛，而且，写python程序真的很轻松。<br>2) 面向对象编程。面向对象是特别好的管理复杂度的工具，应对复杂问题时，用面向对象设计方法很容易将复杂问题拆解为多个简单问题，从而解救我们的大脑。<br>3) 没有使用numpy。numpy实现了很多基础算法，对于实现机器学习算法来说是个必备的工具。但为了降低读者理解的难度，下面的代码只用到了基本的python（省去您去学习numpy的时间）。<br>下面是感知器类的实现，非常简单。去掉注释只有27行，而且还包括为了美观（每行不超过60个字符）而增加的很多换行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">class Perceptron(object):</div><div class="line">    def __init__(self, input_num, activator):</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        初始化感知器，设置输入参数的个数，以及激活函数。</div><div class="line">        激活函数的类型为double -&gt; double</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        self.activator = activator</div><div class="line">        # 权重向量初始化为0</div><div class="line">        self.weights = [0.0 for _ in range(input_num)]</div><div class="line">        # 偏置项初始化为0</div><div class="line">        self.bias = 0.0</div><div class="line">    def __str__(self):</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        打印学习到的权重、偏置项</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        return &apos;weights\t:%s\nbias\t:%f\n&apos; % (self.weights, self.bias)</div><div class="line">    def predict(self, input_vec):</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        输入向量，输出感知器的计算结果</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        # 把input_vec[x1,x2,x3...]和weights[w1,w2,w3,...]打包在一起</div><div class="line">        # 变成[(x1,w1),(x2,w2),(x3,w3),...]</div><div class="line">        # 然后利用map函数计算[x1*w1, x2*w2, x3*w3]</div><div class="line">        # 最后利用reduce求和</div><div class="line">        return self.activator(</div><div class="line">            reduce(lambda a, b: a + b,</div><div class="line">                   map(lambda (x, w): x * w,  </div><div class="line">                       zip(input_vec, self.weights))</div><div class="line">                , 0.0) + self.bias)</div><div class="line">    def train(self, input_vecs, labels, iteration, rate):</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        输入训练数据：一组向量、与每个向量对应的label；以及训练轮数、学习率</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        for i in range(iteration):</div><div class="line">            self._one_iteration(input_vecs, labels, rate)</div><div class="line">    def _one_iteration(self, input_vecs, labels, rate):</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        一次迭代，把所有的训练数据过一遍</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        # 把输入和输出打包在一起，成为样本的列表[(input_vec, label), ...]</div><div class="line">        # 而每个训练样本是(input_vec, label)</div><div class="line">        samples = zip(input_vecs, labels)</div><div class="line">        # 对每个样本，按照感知器规则更新权重</div><div class="line">        for (input_vec, label) in samples:</div><div class="line">            # 计算感知器在当前权重下的输出</div><div class="line">            output = self.predict(input_vec)</div><div class="line">            # 更新权重</div><div class="line">            self._update_weights(input_vec, output, label, rate)</div><div class="line">    def _update_weights(self, input_vec, output, label, rate):</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        按照感知器规则更新权重</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        # 把input_vec[x1,x2,x3,...]和weights[w1,w2,w3,...]打包在一起</div><div class="line">        # 变成[(x1,w1),(x2,w2),(x3,w3),...]</div><div class="line">        # 然后利用感知器规则更新权重</div><div class="line">        delta = label - output</div><div class="line">        self.weights = map(</div><div class="line">            lambda (x, w): w + rate * delta * x,</div><div class="line">            zip(input_vec, self.weights))</div><div class="line">        # 更新bias</div><div class="line">        self.bias += rate * delta</div></pre></td></tr></table></figure></p>
<p>接下来，我们利用这个感知器类去实现and函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">def f(x):</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    定义激活函数f</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    return 1 if x &gt; 0 else 0</div><div class="line">def get_training_dataset():</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    基于and真值表构建训练数据</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    # 构建训练数据</div><div class="line">    # 输入向量列表</div><div class="line">    input_vecs = [[1,1], [0,0], [1,0], [0,1]]</div><div class="line">    # 期望的输出列表，注意要与输入一一对应</div><div class="line">    # [1,1] -&gt; 1, [0,0] -&gt; 0, [1,0] -&gt; 0, [0,1] -&gt; 0</div><div class="line">    labels = [1, 0, 0, 0]</div><div class="line">    return input_vecs, labels    </div><div class="line">def train_and_perceptron():</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    使用and真值表训练感知器</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    # 创建感知器，输入参数个数为2（因为and是二元函数），激活函数为f</div><div class="line">    p = Perceptron(2, f)</div><div class="line">    # 训练，迭代10轮, 学习速率为0.1</div><div class="line">    input_vecs, labels = get_training_dataset()</div><div class="line">    p.train(input_vecs, labels, 10, 0.1)</div><div class="line">    #返回训练好的感知器</div><div class="line">    return p</div><div class="line">if __name__ == &apos;__main__&apos;: </div><div class="line">    # 训练and感知器</div><div class="line">    and_perception = train_and_perceptron()</div><div class="line">    # 打印训练获得的权重</div><div class="line">    print and_perception</div><div class="line">    # 测试</div><div class="line">    print &apos;1 and 1 = %d&apos; % and_perception.predict([1, 1])</div><div class="line">    print &apos;0 and 0 = %d&apos; % and_perception.predict([0, 0])</div><div class="line">    print &apos;1 and 0 = %d&apos; % and_perception.predict([1, 0])</div><div class="line">    print &apos;0 and 1 = %d&apos; % and_perception.predict([0, 1])</div></pre></td></tr></table></figure></p>
<p>将上述程序保存为perceptron.py文件，通过命令行执行这个程序，其运行结果为：</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/11/20/2016-11-20-superviser/" class="next"><button class="ui button teal">NEXT</button></a></div><div data-thread-key="2016/12/01/2016-12-01-deeplearning1/" data-title="深度学习入门(1)：感知器" data-url="http://manongtalk.com/2016/12/01/2016-12-01-deeplearning1/" class="ds-share"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><span class="ds-more">分享到：</span></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul></div></div><div data-thread-key="2016/12/01/2016-12-01-deeplearning1/" data-title="深度学习入门(1)：感知器" data-url="http://manongtalk.com/2016/12/01/2016-12-01-deeplearning1/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"manongtalk"};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
   || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2016 <a href="http://manongtalk.com">卤蛋侠</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and theme by <a href="https://github.com/littlewin-wang/hexo-theme-casual" target="_blank">casual</a></p></div></footer></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script><script src="/js/jquery.scrollex.js"></script><script src="/js/jquery.goup.min.js"></script><script src="/js/semantic.min.js"></script><script src="/js/casual.js"></script><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>$(document).ready(function(){$.goup({trigger:100,bottomOffset:100,locationOffset: 0,title:'',titleAsText:true});});</script><script>(function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){(w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);})(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
_st('install','TvAnFS4AVxjiJUvrZJRB','2.0.0');</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-83962536-1",'auto');ga('send','pageview');</script></div></body></html>
<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 建造者模式（Builder Pattern） | 码农说</title><meta name="description" content="建造者模式（Builder Pattern） - 卤蛋侠"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/icon0.png"><link rel="stylesheet" href="/css/casual.css"><link rel="stylesheet" href="/css/semantic.min.css"><link rel="search" type="application/opensearchdescription+xml" href="http://manongtalk.com/atom.xml" title="码农说"></head><body><div class="sidebar"><div class="ui vertical inverted menu"><div class="h100"></div><h3 class="ui inverted aligned icon header"><div class="content"><a href="/" class="title-link">码农说</a></div></h3><div class="h50"></div><div class="side-nav"><a href="/" target="_self" class="item">HOME<i class="icon home"></i></a><a href="/archives" target="_self" class="item">ARCHIVE<i class="icon archive"></i></a><a href="/tags" target="_self" class="item">TAGS<i class="icon tags"></i></a><a href="/about" target="_self" class="item">INFO<i class="icon info"></i></a></div><div class="item"><div class="ui inverted transparent icon input"><input type="text" placeholder="Search..." class="st-default-search-input"><i class="search icon"></i></div></div><div class="h50"></div></div><div class="h50 mq"><a class="ui teal big label"><i class="content icon"></i></a></div><div class="author-info"><a href="/" class="img-link"><img src="/icon1.png" class="author-photo ui tiny circular image"></a><h4 class="ui aligned icon header"><div class="content">卤蛋侠</div></h4><p class="author-desc">一个程序员的日常 | iOS & Android + Computer Vision | 拜仁慕尼黑粉丝</p><div class="social-outer"><div class="social-inner"><a href="https://drive.google.com/file/d/0B_63yKmxj54bOFlfc2NPX3Y1YXM/view?usp=sharing" target="_blank" class="social-link"><i class="icon wechat"></i></a></div></div></div></div><div class="main"><div class="wrap"><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">建造者模式（Builder Pattern）</h1><div class="post-info"><div class="post-date"><h6 class="ui header"><i class="calendar icon"></i><div class="content">Sep 5, 2016</div></h6></div></div><div class="post-content"><p><strong>概念</strong></p>
<p>建造者模式（Builder Pattern）是一种创建型设计模式，又名：生成器模式。GOF 给建造者模式的定义为：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。这句话说的比较抽象，其实解释一下就是：<strong>将建造复杂对象的过程和组成对象的部件解耦。</strong><br><a id="more"></a><br><strong>用途</strong></p>
<p>假设现在我们是一家网游设计公司，现在我们要”抄袭”梦幻西游这款游戏，你是该公司的游戏角色设计人员。你怎么设计出该游戏中的各种角色呢？ 在梦幻西游来中包括人、仙、魔等种族的角色，而每种不同的种族的角色中又包含龙太子、逍遥生等具体的角色。</p>
<p>作为一个出色的开发人员，我们设计的角色生成系统应该包含以下功能和特性：</p>
<p><em>为了保证游戏平衡，所有角色的基本属性应该一致
</em>因为角色的创建过程可能很复杂，所以角色的生成细节不应该对外暴露<br><em>随时可以新增角色
</em>对某个具体角色的修改应该不影响其他角色</p>
<p>其实，对于角色的设计，我们可以使用抽象工厂模式，将同一种族的角色看成是一个产品族。但是，这样做可能存在一个问题，那就是我们可能要在每个角色的创建过程中都要从头到尾的构建一遍该角色。比如一个角色包含头部、身体。其中头部又包括脸部、和其他部位。其中脸部又包含眉毛、嘴巴、鼻子等部位。整个角色的创建过程是极其复杂的。很容易遗漏其中的某个步骤。</p>
<p>那么，我们可以将这些具体部位的创建工作和对象的创建进行解耦。这就是建造者模式。</p>
<p><strong>实现方式</strong></p>
<p>建造者模式包含如下角色：</p>
<p>Builder：抽象建造者(Builder)</p>
<p>ConcreteBuilder：具体建造者(CommonBuilder、SuperBuilder)</p>
<p>Director：指挥者(Director)</p>
<p>Product：产品角色(Role)</p>

<p>这里采用设计角色的例子，为了便于理解，我们只创建两个角色，分别是普通角色和超级角色。他们都有设置头部、脸部、身体、气血值、魔法值、能量值等方法。值得注意的是设置脸部是依赖于设置头部的，要有先后顺序。</p>
<p>产品角色：Role</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Role &#123;</div><div class="line"></div><div class="line">    private String head; //头部</div><div class="line">    private String face; //脸部（脸部依赖于头部）</div><div class="line">    private String body; //身体</div><div class="line">    private Double hp;   //生命值</div><div class="line">    private Double sp;   //能量值</div><div class="line">    private Double mp;   //魔法值</div><div class="line"></div><div class="line">    //setter and getter </div><div class="line">     // toString </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>抽象建造者：Builder</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public abstract class Builder &#123;</div><div class="line"></div><div class="line">    protected Role role = new Role();</div><div class="line"></div><div class="line">    public abstract void buildHead();</div><div class="line"></div><div class="line">    public abstract void buildFace();</div><div class="line"></div><div class="line">    public abstract void buildBody();</div><div class="line"></div><div class="line">    public abstract void buildHp();</div><div class="line"></div><div class="line">    public abstract void buildSp();</div><div class="line"></div><div class="line">    public abstract void buildMp();</div><div class="line"></div><div class="line">    public Role getResult() &#123;</div><div class="line">        return role;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体建造者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">public class CommonRoleBuilder extends Builder &#123;</div><div class="line"></div><div class="line">    private Role role = new Role();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void buildHead() &#123;</div><div class="line">        role.setBody(&quot;common head&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void buildFace() &#123;</div><div class="line">        role.setFace(&quot;common face&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void buildBody() &#123;</div><div class="line">        role.setBody(&quot;common body&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void buildHp() &#123;</div><div class="line">        role.setHp(100d);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void buildSp() &#123;</div><div class="line">        role.setSp(100d);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void buildMp() &#123;</div><div class="line">        role.setMp(100d);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Role getResult() &#123;</div><div class="line">        return role;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class SuperRoleBuilder extends Builder &#123;</div><div class="line"></div><div class="line">    private Role role = new Role();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void buildHead() &#123;</div><div class="line">        role.setBody(&quot;super head&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void buildFace() &#123;</div><div class="line">        role.setFace(&quot;super face&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void buildBody() &#123;</div><div class="line">        role.setBody(&quot;super body&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void buildHp() &#123;</div><div class="line">        role.setHp(120d);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void buildSp() &#123;</div><div class="line">        role.setSp(120d);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void buildMp() &#123;</div><div class="line">        role.setMp(120d);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Role getResult() &#123;</div><div class="line">        return role;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>指挥者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Director &#123;</div><div class="line"></div><div class="line">    public void construct(Builder builder)&#123;</div><div class="line">        builder.buildBody();</div><div class="line">        builder.buildHead();</div><div class="line">        builder.buildFace();</div><div class="line">        builder.buildHp();</div><div class="line">        builder.buildMp();</div><div class="line">        builder.buildSp();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class Main &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">        Director director = new Director();</div><div class="line">        Builder commonBuilder = new CommonRoleBuilder();</div><div class="line"></div><div class="line">        director.construct(commonBuilder);</div><div class="line">        Role commonRole = commonBuilder.getResult();</div><div class="line">        System.out.println(commonRole);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里，一个建造者模式已经完成了，是不是很简单？</p>
<p>再回到之前的需求，看看我们是否都满足？</p>
<p>由于建造角色的过程比较复杂，其中还有相互依赖关系（如脸部依赖于头部），所以我们使用建造者模式将将建造复杂对象的过程和组成对象的部件解耦。这样既保证了基本属性全都一致（这里的一致指的是该包含的应该全都包含）也封装了其中的具体实现细节。<br>同时，在修改某个具体角色的时候我们只需要修改对应的具体角色就可以了，不会影响到其他角色。<br>如果需要新增角色，只要再增加一个具体建造者，并在该建造者中写好具体细节的建造部分代码就OK了。</p>
<p><strong>建造者模式的优缺点</strong></p>
<p>优点</p>
<p>建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在导演类中对整体而言可以取得比较好的稳定性。</p>
<p>在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</p>
<p>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</p>
<p>其次，建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。</p>
<p>缺点</p>
<p>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</p>
<p>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</p>
<p><strong>适用环境</strong></p>
<p>在以下情况下可以使用建造者模式：</p>
<p>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。<br>需要生成的产品对象的属性相互依赖，需要指定其生成顺序。<br>对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。<br>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</p>
<p><strong>建造者模式与工厂模式的区别</strong></p>
<p>我们可以看到，建造者模式与工厂模式是极为相似的，总体上，建造者模式仅仅只比工厂模式多了一个”指挥者”的角色。在建造者模式的类图中，假如把这个导演类看做是最终调用的客户端，那么图中剩余的部分就可以看作是一个简单的工厂模式了。</p>
<p>与工厂模式相比，建造者模式一般用来创建更为复杂的对象，因为对象的创建过程更为复杂，因此将对象的创建过程独立出来组成一个新的类——导演类。</p>
<p>也就是说，工厂模式是将对象的全部创建过程封装在工厂类中，由工厂类向客户端提供最终的产品；而建造者模式中，建造者类一般只提供产品类中各个组件的建造，而将具体建造过程交付给导演类。由导演类负责将各个组件按照特定的规则组建为产品，然后将组建好的产品交付给客户端。</p>
<p>建造者模式与工厂模式类似，适用的场景也很相似。一般来说，如果产品的建造很复杂，那么请用工厂模式；如果产品的建造更复杂，那么请用建造者模式。哈哈哈。。。</p>
<p><strong>总结</strong></p>
<p>建造者模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p>在建造者模式的结构中引入了一个指挥者类，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。</p>
<p><strong>建造者模式的实践</strong></p>
<p>假设你有一个类，其中包含大量属性。就像下面的User类一样。假设你想让这个类是不可变的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class User &#123;</div><div class="line">    private final String firstName;    //required</div><div class="line">    private final String lastName;    //required</div><div class="line">    private final int age;    //optional</div><div class="line">    private final String phone;    //optional</div><div class="line">    private final String address;    //optional</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这样的类中，有一些属性是必须的（required）而另外一些是可选的（optional）。如果你想要构造这个类的实例，你会怎么做？把所有属性都设置成final类型，然后使用构造函数初始化他们嘛？但是，如果你想让这个类的调用者可以从众多的可选参数中选择自己想要的进行设置怎么办？</p>
<p>第一个可想到的方案可能是重载多个构造函数，其中有一个只初始化必要的参数，还有一个会在初始化必要的参数同时初始化所有的可选参数，还有一些其他的构造函数介于两者之间，就是一次多初始化一个可选参数。就像下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public User(String firstName, String lastName) &#123;</div><div class="line">    this(firstName, lastName, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public User(String firstName, String lastName, int age) &#123;</div><div class="line">    this(firstName, lastName, age, &quot;&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public User(String firstName, String lastName, int age, String phone) &#123;</div><div class="line">    this(firstName, lastName, age, phone, &quot;&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public User(String firstName, String lastName, int age, String phone, String address) &#123;</div><div class="line">    this.firstName = firstName;</div><div class="line">    this.lastName = lastName;</div><div class="line">    this.age = age;</div><div class="line">    this.phone = phone;</div><div class="line">    this.address = address;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先可以肯定的是，这样做是可以满足要求的。当然，这种方式的缺点也是很明显的。当一个类中只有几个参数的时候还好，如果一旦类中的参数逐渐增大，那么这个类就会变得很难阅读和维护。更重要的是，这样的一个类，调用者会很难使用。我到底应该使用哪个构造方法？是包含两个参数的还是包含三个参数的？如果我没有传递值的话那些属性的默认值是什么？如果我只想对address赋值而不对age和phone赋值怎么办？遇到这种情况可能我只能调用那个参数最全的构造函数，然后对于我不想要的参数值传递一个默认值。此外，如果多个参数的类型都相同那就很容易让人困惑，第一个String类型的参数到底是number还是address呢？</p>
<p>还有没有其他方案可选择呢？我们可以遵循JavaBean规范，定义一个只包含无参数的构造方法和getter、setter方法的JavaBean。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class User &#123;</div><div class="line">    private String firstName; // required</div><div class="line">    private String lastName; // required</div><div class="line">    private int age; // optional</div><div class="line">    private String phone; // optional</div><div class="line">    private String address;  //optional</div><div class="line"></div><div class="line">    public String getFirstName() &#123;</div><div class="line">        return firstName;</div><div class="line">    &#125;</div><div class="line">    public void setFirstName(String firstName) &#123;</div><div class="line">        this.firstName = firstName;</div><div class="line">    &#125;</div><div class="line">    public String getLastName() &#123;</div><div class="line">        return lastName;</div><div class="line">    &#125;</div><div class="line">    public void setLastName(String lastName) &#123;</div><div class="line">        this.lastName = lastName;</div><div class="line">    &#125;</div><div class="line">    public int getAge() &#123;</div><div class="line">        return age;</div><div class="line">    &#125;</div><div class="line">    public void setAge(int age) &#123;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line">    public String getPhone() &#123;</div><div class="line">        return phone;</div><div class="line">    &#125;</div><div class="line">    public void setPhone(String phone) &#123;</div><div class="line">        this.phone = phone;</div><div class="line">    &#125;</div><div class="line">    public String getAddress() &#123;</div><div class="line">        return address;</div><div class="line">    &#125;</div><div class="line">    public void setAddress(String address) &#123;</div><div class="line">        this.address = address;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式看上去很容易阅读和维护。对于调用者来说，我只需要创建一个空的对象，然后对于我想设置的参数调用setter方法设置就好了。这难道还有什么问题吗？其实存在两个问题。第一个问题是该类的实例状态不固定。如果你想创建一个User对象，该对象的5个属性都要赋值，那么直到所有的setXX方法都被调用之前，该对象都没有一个完整的状态。这意味着在该对象状态还不完整的时候，一部分客户端程序可能看见这个对象并且以为该对象已经构造完成。这种方法的第二个不足是User类是易变的（因为没有属性是final的）。你将会失去不可变对象带来的所有优点。</p>
<p>幸运的是应对这种场景我们有第三种选择，建造者模式。解决方案类似如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">public class User &#123;</div><div class="line">    private final String firstName; // required</div><div class="line">    private final String lastName; // required</div><div class="line">    private final int age; // optional</div><div class="line">    private final String phone; // optional</div><div class="line">    private final String address; // optional</div><div class="line"></div><div class="line">    private User(UserBuilder builder) &#123;</div><div class="line">        this.firstName = builder.firstName;</div><div class="line">        this.lastName = builder.lastName;</div><div class="line">        this.age = builder.age;</div><div class="line">        this.phone = builder.phone;</div><div class="line">        this.address = builder.address;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getFirstName() &#123;</div><div class="line">        return firstName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getLastName() &#123;</div><div class="line">        return lastName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getAge() &#123;</div><div class="line">        return age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getPhone() &#123;</div><div class="line">        return phone;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getAddress() &#123;</div><div class="line">        return address;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static class UserBuilder &#123;</div><div class="line">        private final String firstName;</div><div class="line">        private final String lastName;</div><div class="line">        private int age;</div><div class="line">        private String phone;</div><div class="line">        private String address;</div><div class="line"></div><div class="line">        public UserBuilder(String firstName, String lastName) &#123;</div><div class="line">            this.firstName = firstName;</div><div class="line">            this.lastName = lastName;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public UserBuilder age(int age) &#123;</div><div class="line">            this.age = age;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public UserBuilder phone(String phone) &#123;</div><div class="line">            this.phone = phone;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public UserBuilder address(String address) &#123;</div><div class="line">            this.address = address;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public User build() &#123;</div><div class="line">            return new User(this);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>值得注意的几个要点:</p>
<p>User类的构造函数是私有的，这意味着你不能在外面直接创建这个类的对象。<br>该类是不可变的。所有属性都是final类型的，在构造方法里面被赋值。另外，我们只为它们提供了getter方法。<br>builder类使用流式接口风格，让客户端代码阅读起来更容易（我们马上就会看到一个它的例子）<br>builder的构造方法只接收必要的参数，为了确保这些属性在构造方法里赋值，只有这些属性被定义成final类型。</p>
<p>使用建造者模式有在本文开始时提到的两种方法的所有优点，并且没有它们的缺点。客户端代码写起来更简单，更重要的是，更易读。我听过的关于该模式的唯一批判是你必须在builder类里面复制类的属性。然而，考虑到这个事实，builder类通常是需要建造的类的一个静态类成员，它们一起扩展起来相当容易。</p>
<p>现在，试图创建一个新的User对象的客户端代码看起来如何那？让我们来看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public User getUser() &#123;</div><div class="line">    return new</div><div class="line">            User.UserBuilder(&quot;Jhon&quot;, &quot;Doe&quot;)</div><div class="line">            .age(30)</div><div class="line">            .phone(&quot;1234567&quot;)</div><div class="line">            .address(&quot;Fake address 1234&quot;)</div><div class="line">            .build();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果UserBuilder没有设置为static的，以上代码会有编译错误。错误提示：User is not an enclosing class</p>
<p>以上代码看上去相当整洁。我们可以只通过一行代码就可以创建一个User对象，并且这行代码也很容易读懂。除此之外，这样还能确保无论何时你想获取该类的对象都不会是不完整的：因为创建对象的过程是一气呵成的，一旦对象创建完成之后就不可修改了。</p>
<p>这种模式非常灵活，一个单独的builder类可以通过在调用build方法之前改变builder的属性来创建多个对象。builder类甚至可以在每次调用之间自动补全一些生成的字段，例如一个id或者序列号。</p>
<p>值得注意的是，像构造函数一样，builder可以对参数的合法性进行检查，一旦发现参数不合法可以抛出IllegalStateException异常。</p>
<p>但是，很重要的一点是，如果要检查参数的合法性，一定要先把参数传递给对象，然后在检查对象中的参数是否合法。其原因是因为builder并不是线程安全的。如果我们在创建真正的对象之前验证参数，参数值可能被另一个线程在参数验证完和参数被拷贝完成之间的时间修改。这段时间周期被称作“脆弱之窗”。我们的例子中情况如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public User build() &#123;</div><div class="line">    User user = new user(this);</div><div class="line">    if (user.getAge() &gt; 120) &#123;</div><div class="line">        throw new IllegalStateException(“Age out of range”); // thread-safe</div><div class="line">    &#125;</div><div class="line">    return user;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上一个代码版本是线程安全的因为我们首先创建user对象，然后在不可变对象上验证条件约束。下面的代码在功能上看起来一样但是它不是线程安全的，你应该避免这么做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public User build() &#123;</div><div class="line">    if (age &gt; 120) &#123;</div><div class="line">        throw new IllegalStateException(“Age out of range”); // bad, not thread-safe</div><div class="line">    &#125;</div><div class="line">    // This is the window of opportunity for a second thread to modify the value of age</div><div class="line">    return new User(this);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>建造者模式最后的一个优点是builder可以作为参数传递给一个方法，让该方法有为客户端创建一个或者多个对象的能力，而不需要知道创建对象的任何细节。为了这么做你可能通常需要一个如下所示的简单接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Builder &#123;</div><div class="line">    T build();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>借用之前的User例子，UserBuilder类可以实现Builder。如此，我们可以有如下的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UserCollection buildUserCollection(Builder userBuilder)&#123;...&#125;</div></pre></td></tr></table></figure>
<p>关于这这最后一个优点的部分内容并没太看懂，希望有理解的人能过不吝赐教。</p>
<p>好吧，这确实是一篇很长的文章。总而言之，建造者模式在多于几个参数（虽然不是很科学准确，但是我通常把四个参数作为使用建造者模式的一个很好的指示器），特别是当大部分参数都是可选的时候。你可以让客户端代码在阅读，写和维护方面更容易。另外，你的类可以保持不可变特性，让你的代码更安全。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/09/18/2016-09-16-adapter/" class="prev"><button class="ui button teal">PREV</button></a><a href="/2016/09/04/2016-09-04-factory-compare/" class="next"><button class="ui button teal">NEXT</button></a></div><div class="copyright"><p>© 2016 <a href="http://manongtalk.com">卤蛋侠</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and theme by <a href="https://github.com/littlewin-wang/hexo-theme-casual" target="_blank">casual</a></p></div></footer></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script><script src="/js/jquery.scrollex.js"></script><script src="/js/jquery.goup.min.js"></script><script src="/js/semantic.min.js"></script><script src="/js/casual.js"></script><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>$(document).ready(function(){$.goup({trigger:100,bottomOffset:100,locationOffset: 0,title:'',titleAsText:true});});</script><script>(function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){(w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);})(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
_st('install','TvAnFS4AVxjiJUvrZJRB','2.0.0');</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-83962536-1",'auto');ga('send','pageview');</script></div></body></html>